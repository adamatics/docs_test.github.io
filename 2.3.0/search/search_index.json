{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to <code>adalib</code>","text":"<p>The adalib base module exposes the core integrations of all the components in the AdaLab platform.</p> <p>This package provides a programmatic interface to the components and functionalities of AdaLab.</p>"},{"location":"#package-structure","title":"Package structure","text":"<p><code>adalib</code> is composed of several modules, each of them corresponding to an AdaLab component:</p> <ul> <li>Adaboard: communication with the Adaboard API.</li> <li>Apps: interaction with deployed apps.</li> <li>Cards: operations on Gallery cards (create, delete, etc.).</li> <li>Harbor: operations with container images and metadata.</li> <li>Issues: interaction with card issues (view, update, etc.).</li> <li>Keywords: actions on card keywords (create, delete, etc.).</li> <li>Lab: management of the user's Lab environment.</li> <li>Notebooks: execution and scheduling of notebooks.</li> <li>Superset: integration with Superset data and visualization objects.</li> </ul> <p>Use the navigation panel to find the documentation of the module you want to know more about.</p>"},{"location":"adaboard/","title":"<code>adalib.adaboard</code>","text":"<p>The Adaboard sub-package exposes the core integrations with the Adaboard API.</p>"},{"location":"adaboard/#adalib.adaboard-functions","title":"Functions","text":""},{"location":"adaboard/#adalib.adaboard.build_request_url","title":"build_request_url","text":"<pre><code>build_request_url(path)\n</code></pre> <p>Build the URL to hit adaboard on.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The relative path to hit adaboard on.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The complete URL to hit adaboard on.</p> Source code in <code>adalib/adaboard/adaboard.py</code> <pre><code>def build_request_url(path: str) -&gt; str:\n    \"\"\"Build the URL to hit adaboard on.\n\n    :param path: The relative path to hit adaboard on.\n    :type path: str\n    :return: The complete URL to hit adaboard on.\n    :rtype: str\n    \"\"\"\n    adalib_config = config.get_config()\n    url_scheme = (\n        \"https://\" if adalib_config.ENVIRONMENT == \"external\" else \"http://\"\n    )\n    api_extension = (\n        \"/adaboard/api\" if adalib_config.ENVIRONMENT == \"external\" else \"\"\n    )\n    return (\n        url_scheme\n        + adalib_config.SERVICES[\"adaboard-api\"][\"netloc\"]\n        + api_extension\n        + f\"/{path}\"\n    )\n</code></pre>"},{"location":"adaboard/#adalib.adaboard.get_user","title":"get_user","text":"<pre><code>get_user(include_notification_preferences=False)\n</code></pre> <p>Get user data.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User ID</p> required <code>include_notification_preferences</code> <code>bool</code> <p>Flag whether the notification preferences should be included</p> <code>False</code> Source code in <code>adalib/adaboard/adaboard.py</code> <pre><code>def get_user(\n    include_notification_preferences: bool = False,\n) -&gt; dict:\n    \"\"\"Get user data.\n\n    :param user_id: User ID\n    :type user_id: str\n    :param include_notification_preferences: Flag whether the notification\n        preferences should be included\n    :type include_notification_preferences: bool\n    \"\"\"\n    user = request_adaboard(path=\"users/self\").json()\n    notifications = request_adaboard(path=\"nosy/settings/\").json()\n    user[\"notifications\"] = notifications\n\n    if include_notification_preferences:\n        notification_preferences = request_adaboard(\n            path=\"nosy/preferences/\"\n        ).json()\n        notification_preferences = [\n            _unravel_notification(x)\n            for x in notification_preferences[\"preferences\"]\n        ]\n        user[\"notifications\"][\"preferences\"] = notification_preferences\n\n    return user\n</code></pre>"},{"location":"adaboard/#adalib.adaboard.request_adaboard","title":"request_adaboard","text":"<pre><code>request_adaboard(path, method=requests.get, **kwargs)\n</code></pre> <p>Function to hit the adaboard api at the specified url and raise for error on response.</p> <p>Note: All kwargs passed are directly sent through to the request function.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path to hit adaboard on (base url will be injected automatically)</p> required <code>method</code> <code>function, optional</code> <p>method to use to query adaboard, defaults to requests.get</p> <code>get</code> <p>Returns:</p> Type Description <code>response</code> <p>response from adaboard</p> Source code in <code>adalib/adaboard/adaboard.py</code> <pre><code>def request_adaboard(\n    path: str,\n    method=requests.get,\n    **kwargs,\n) -&gt; requests.models.Response:\n    \"\"\"Function to hit the adaboard api at the specified url and raise for error on response.\n\n    Note: All kwargs passed are directly sent through to the request function.\n\n    :param path: path to hit adaboard on (base url will be injected automatically)\n    :type path: str\n    :param method: method to use to query adaboard, defaults to requests.get\n    :type method: function, optional\n    :return: response from adaboard\n    :rtype: response\n    \"\"\"\n    # Construct authentication header for adaboard\n    adalib_config = config.get_config()\n    adaboard_token = keycloak.get_client_token(\n        audience_client_id=adalib_config.KEYCLOAK_CLIENTS[\"adaboard-api\"]\n    )\n\n    headers = {\n        \"authorization\": f\"Bearer {adaboard_token['access_token']}\",\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\",\n    }\n\n    request_url = build_request_url(path)\n\n    # Query adaboard and raise for status\n    response = method(request_url, headers=headers, **kwargs)\n    response.raise_for_status()\n\n    return response\n</code></pre>"},{"location":"apps/","title":"<code>adalib.apps</code>","text":"<p>The Apps sub-package exposes the core integrations of the deployed apps in AdaLab.</p>"},{"location":"apps/#adalib.apps-functions","title":"Functions","text":""},{"location":"apps/#adalib.apps.delete_app","title":"delete_app","text":"<pre><code>delete_app(app_id)\n</code></pre> <p>Delete a deployed app from AdaLab.</p> <p>Parameters:</p> Name Type Description Default <code>app_id</code> <code>str</code> <p>the app's ID</p> required Source code in <code>adalib/apps/apps.py</code> <pre><code>def delete_app(app_id: str) -&gt; None:\n    \"\"\"Delete a deployed app from AdaLab.\n\n    :param app_id: the app's ID\n    :type app_id: str\n    \"\"\"\n\n    adaboard.request_adaboard(path=f\"apps/{app_id}/\", method=requests.delete)\n    return None\n</code></pre>"},{"location":"apps/#adalib.apps.deploy_app","title":"deploy_app","text":"<pre><code>deploy_app(name, description, metadata_id, url_path_prefix, stripped_prefix=True, port=80, replicas=1, environment_variables={}, max_cpu=1.0, min_cpu=0.0, max_ram=500, min_ram=20, command='', acl_type='public', acl_userlist=[], acl_group_names=[], idp_enabled=False, idp_scope='')\n</code></pre> <p>Deploy an app to AdaLab from an existing metadata object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the app's name</p> required <code>description</code> <code>str</code> <p>the app's description</p> required <code>metadata_id</code> <code>int</code> <p>the ID of the metadata object</p> required <code>url_path_prefix</code> <code>str</code> <p>URL endpoint to deploy the app to</p> required <code>stripped_prefix</code> <code>bool</code> <p>whether to strip the apps/{app_url} prefix from the URL, defaults to True</p> <code>True</code> <code>port</code> <code>int</code> <p>the port where the app is served from, defaults to 80</p> <code>80</code> <code>replicas</code> <code>int</code> <p>number of replicas to deploy, defaults to 1</p> <code>1</code> <code>environment_variables</code> <code>dict</code> <p>environment variables to pass to the app, defaults to {}</p> <code>{}</code> <code>max_cpu</code> <code>float</code> <p>maximum CPU usage allowed (vCPU), defaults to 1.0</p> <code>1.0</code> <code>min_cpu</code> <code>float</code> <p>minimum CPU usage allowed (vCPU), defaults to 0.0</p> <code>0.0</code> <code>max_ram</code> <code>int</code> <p>maximum RAM usage allowed (Mb), defaults to 500</p> <code>500</code> <code>min_ram</code> <code>int</code> <p>minimum RAM usage allowed (Mb), defaults to 20</p> <code>20</code> <code>command</code> <code>str</code> <p>command to start up the app, defaults to \"\"</p> <code>''</code> <code>acl_type</code> <code>str</code> <p>type of access control list, defaults to \"public\"</p> <code>'public'</code> <code>acl_userlist</code> <code>list[str]</code> <p>list of users allowed to access the app when acl_type=\"userlist\", defaults to []</p> <code>[]</code> <code>acl_group_names</code> <code>list[str]</code> <p>list of groups allowed to access the app when acl_type=\"group\", defaults to []</p> <code>[]</code> <code>idp_enabled</code> <code>bool</code> <p>whether to enable IdP token in app headers, defaults to False</p> <code>False</code> <code>idp_scope</code> <code>str</code> <p>IdP token scope, defaults to \"\"</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>the app's ID</p> Source code in <code>adalib/apps/apps.py</code> <pre><code>def deploy_app(\n    name: str,\n    description: str,\n    metadata_id: int,\n    url_path_prefix: str,\n    stripped_prefix: bool = True,\n    port: int = 80,\n    replicas: int = 1,\n    environment_variables: dict = {},\n    max_cpu: float = 1.0,\n    min_cpu: float = 0.0,\n    max_ram: int = 500,\n    min_ram: int = 20,\n    command: str = \"\",\n    acl_type: str = \"public\",\n    acl_userlist: list[str] = [],\n    acl_group_names: list[str] = [],\n    idp_enabled: bool = False,\n    idp_scope: str = \"\",\n) -&gt; str:\n    \"\"\"Deploy an app to AdaLab from an existing metadata object.\n\n    :param name: the app's name\n    :type name: str\n    :param description: the app's description\n    :type description: str\n    :param metadata_id: the ID of the metadata object\n    :type metadata_id: int\n    :param url_path_prefix: URL endpoint to deploy the app to\n    :type url_path_prefix: str\n    :param stripped_prefix: whether to strip the apps/{app_url} prefix from the URL, defaults to True\n    :type stripped_prefix: bool, optional\n    :param port: the port where the app is served from, defaults to 80\n    :type port: int, optional\n    :param replicas: number of replicas to deploy, defaults to 1\n    :type replicas: int, optional\n    :param environment_variables: environment variables to pass to the app, defaults to {}\n    :type environment_variables: dict, optional\n    :param max_cpu: maximum CPU usage allowed (vCPU), defaults to 1.0\n    :type max_cpu: float, optional\n    :param min_cpu: minimum CPU usage allowed (vCPU), defaults to 0.0\n    :type min_cpu: float, optional\n    :param max_ram: maximum RAM usage allowed (Mb), defaults to 500\n    :type max_ram: int, optional\n    :param min_ram: minimum RAM usage allowed (Mb), defaults to 20\n    :type min_ram: int, optional\n    :param command: command to start up the app, defaults to \"\"\n    :type command: str, optional\n    :param acl_type: type of access control list, defaults to \"public\"\n    :type acl_type: str, optional\n    :param acl_userlist: list of users allowed to access the app when acl_type=\"userlist\", defaults to []\n    :type acl_userlist: list, optional\n    :param acl_group_names: list of groups allowed to access the app when acl_type=\"group\", defaults to []\n    :type acl_group_names: list, optional\n    :param idp_enabled: whether to enable IdP token in app headers, defaults to False\n    :type idp_enabled: bool, optional\n    :param idp_scope: IdP token scope, defaults to \"\"\n    :type idp_scope: str, optional\n    :return: the app's ID\n    :rtype: str\n    \"\"\"\n\n    # Build the payload for the request\n    payload = {\n        \"name\": name,\n        \"description\": description,\n        \"metadata_id\": metadata_id,\n        \"url_path_prefix\": url_path_prefix,\n        \"stripped_prefix\": stripped_prefix,\n        \"port\": port,\n        \"replicas\": replicas,\n        \"environment_variables\": environment_variables,\n        \"max_cpu\": max_cpu,\n        \"min_cpu\": min_cpu,\n        \"max_ram\": max_ram,\n        \"min_ram\": min_ram,\n        \"command\": command,\n        \"acl_type\": acl_type,\n        \"acl_userlist\": acl_userlist,\n        \"acl_group_names\": acl_group_names,\n        \"idp_enabled\": idp_enabled,\n        \"idp_scope\": idp_scope,\n    }\n\n    # Check that the app configuration is valid and update payload\n    assert (\n        acl_type in ALLOWED_ACL_TYPES\n    ), f\"ACL type must be one of {', '.join([x for x in ALLOWED_ACL_TYPES])}\"\n    if acl_type == \"public\":\n        payload.pop(\"acl_userlist\")\n        payload.pop(\"acl_group_names\")\n    elif acl_type == \"userlist\":\n        assert (\n            isinstance(acl_userlist, list) and len(acl_userlist) &gt; 0\n        ), \"ACL type is userlist but no users were specified.\"\n        payload.pop(\"acl_group_names\")\n    elif acl_type == \"group\":\n        assert (\n            isinstance(acl_group_names, list) and len(acl_group_names) &gt; 0\n        ), \"ACL type is group but no groups were specified.\"\n        payload.pop(\"acl_userlist\")\n\n    # Deploy the app\n    response = adaboard.request_adaboard(\n        path=\"apps/\", method=requests.post, json=payload\n    ).json()\n\n    # Return the ID of the deployed app\n    return response[\"id\"]\n</code></pre>"},{"location":"apps/#adalib.apps.edit_app","title":"edit_app","text":"<pre><code>edit_app(app_id, name=None, description=None, metadata_id=None, url_path_prefix=None, stripped_prefix=None, port=None, replicas=None, environment_variables=None, max_cpu=None, min_cpu=None, max_ram=None, min_ram=None, command=None, acl_type=None, acl_userlist=None, acl_group_names=None, idp_enabled=None, idp_scope=None)\n</code></pre> <p>Edit a deployed app's configuration.</p> <p>Parameters:</p> Name Type Description Default <code>app_id</code> <code>str</code> <p>the app's ID</p> required <code>name</code> <code>str</code> <p>the app's name, defaults to None (old one)</p> <code>None</code> <code>description</code> <code>str</code> <p>the app's description, defaults to None (old one)</p> <code>None</code> <code>metadata_id</code> <code>int</code> <p>the ID of the metadata object, defaults to None (old one)</p> <code>None</code> <code>url_path_prefix</code> <code>str</code> <p>URL endpoint to deploy the app to, defaults to None (old one)</p> <code>None</code> <code>stripped_prefix</code> <code>bool</code> <p>whether to strip the apps/{app_url} prefix from the URL, defaults to None (old one)</p> <code>None</code> <code>port</code> <code>int</code> <p>the port where the app is served from, defaults to None (old one)</p> <code>None</code> <code>replicas</code> <code>int</code> <p>number of replicas to deploy, defaults to None (old one)</p> <code>None</code> <code>environment_variables</code> <code>dict</code> <p>environment variables to pass to the app, defaults to None (old one)</p> <code>None</code> <code>max_cpu</code> <code>float</code> <p>maximum CPU usage allowed (vCPU), defaults to None (old one)</p> <code>None</code> <code>min_cpu</code> <code>float</code> <p>minimum CPU usage allowed (vCPU), defaults to None (old one)</p> <code>None</code> <code>max_ram</code> <code>int</code> <p>maximum RAM usage allowed (Mb), defaults to None (old one)</p> <code>None</code> <code>min_ram</code> <code>int</code> <p>minimum RAM usage allowed (Mb), defaults to None (old one)</p> <code>None</code> <code>command</code> <code>str</code> <p>command to start up the app, defaults to None (old one)</p> <code>None</code> <code>acl_type</code> <code>str</code> <p>type of access control list, defaults to None (old one)</p> <code>None</code> <code>acl_userlist</code> <code>list[str]</code> <p>list of users allowed to access the app when acl_type=\"userlist\", defaults to None (old one)</p> <code>None</code> <code>acl_group_names</code> <code>list[str]</code> <p>list of groups allowed to access the app when acl_type=\"group\", defaults to None (old one)</p> <code>None</code> <code>idp_enabled</code> <code>bool</code> <p>whether to enable IdP token in app headers, defaults to None (old one)</p> <code>None</code> <code>idp_scope</code> <code>str</code> <p>IdP token scope, defaults to None (old one)</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>nothing</p> Source code in <code>adalib/apps/apps.py</code> <pre><code>def edit_app(\n    app_id: str,\n    name: str = None,\n    description: str = None,\n    metadata_id: int = None,\n    url_path_prefix: str = None,\n    stripped_prefix: bool = None,\n    port: int = None,\n    replicas: int = None,\n    environment_variables: dict = None,\n    max_cpu: float = None,\n    min_cpu: float = None,\n    max_ram: int = None,\n    min_ram: int = None,\n    command: str = None,\n    acl_type: str = None,\n    acl_userlist: list[str] = None,\n    acl_group_names: list[str] = None,\n    idp_enabled: bool = None,\n    idp_scope: str = None,\n) -&gt; None:\n    \"\"\"Edit a deployed app's configuration.\n\n    :param app_id: the app's ID\n    :type app_id: str\n    :param name: the app's name, defaults to None (old one)\n    :type name: str, optional\n    :param description: the app's description, defaults to None (old one)\n    :type description: str, optional\n    :param metadata_id: the ID of the metadata object, defaults to None (old one)\n    :type metadata_id: int, optional\n    :param url_path_prefix: URL endpoint to deploy the app to, defaults to None (old one)\n    :type url_path_prefix: str, optional\n    :param stripped_prefix: whether to strip the apps/{app_url} prefix from the URL, defaults to None (old one)\n    :type stripped_prefix: bool, optional\n    :param port: the port where the app is served from, defaults to None (old one)\n    :type port: int, optional\n    :param replicas: number of replicas to deploy, defaults to None (old one)\n    :type replicas: int, optional\n    :param environment_variables: environment variables to pass to the app, defaults to None (old one)\n    :type environment_variables: dict, optional\n    :param max_cpu: maximum CPU usage allowed (vCPU), defaults to None (old one)\n    :type max_cpu: float, optional\n    :param min_cpu: minimum CPU usage allowed (vCPU), defaults to None (old one)\n    :type min_cpu: float, optional\n    :param max_ram: maximum RAM usage allowed (Mb), defaults to None (old one)\n    :type max_ram: int, optional\n    :param min_ram: minimum RAM usage allowed (Mb), defaults to None (old one)\n    :type min_ram: int, optional\n    :param command: command to start up the app, defaults to None (old one)\n    :type command: str, optional\n    :param acl_type: type of access control list, defaults to None (old one)\n    :type acl_type: str, optional\n    :param acl_userlist: list of users allowed to access the app when acl_type=\"userlist\", defaults to None (old one)\n    :type acl_userlist: list, optional\n    :param acl_group_names: list of groups allowed to access the app when acl_type=\"group\", defaults to None (old one)\n    :type acl_group_names: list, optional\n    :param idp_enabled: whether to enable IdP token in app headers, defaults to None (old one)\n    :type idp_enabled: bool, optional\n    :param idp_scope: IdP token scope, defaults to None (old one)\n    :type idp_scope: str, optional\n    :return: nothing\n    :rtype: None\n    \"\"\"\n\n    # Collect configuration options\n    app_config = {\n        \"name\": name,\n        \"description\": description,\n        \"metadata_id\": metadata_id,\n        \"url_path_prefix\": url_path_prefix,\n        \"stripped_prefix\": stripped_prefix,\n        \"port\": port,\n        \"replicas\": replicas,\n        \"environment_variables\": environment_variables,\n        \"max_cpu\": max_cpu,\n        \"min_cpu\": min_cpu,\n        \"max_ram\": max_ram,\n        \"min_ram\": min_ram,\n        \"command\": command,\n        \"acl_type\": acl_type,\n        \"acl_userlist\": acl_userlist,\n        \"acl_group_names\": acl_group_names,\n        \"idp_enabled\": idp_enabled,\n        \"idp_scope\": idp_scope,\n    }\n\n    # Check that the app configuration is valid and update payload\n    if acl_type:\n        assert (\n            acl_type in ALLOWED_ACL_TYPES\n        ), f\"ACL type must be one of {', '.join([x for x in ALLOWED_ACL_TYPES])}\"\n        if acl_type == \"public\":\n            app_config.pop(\"acl_userlist\")\n            app_config.pop(\"acl_group_names\")\n        elif acl_type == \"userlist\":\n            assert (\n                isinstance(acl_userlist, list) and len(acl_userlist) &gt; 0\n            ), \"ACL type is userlist but no users were specified.\"\n            app_config.pop(\"acl_group_names\")\n        elif acl_type == \"group\":\n            assert (\n                isinstance(acl_group_names, list) and len(acl_group_names) &gt; 0\n            ), \"ACL type is group but no groups were specified.\"\n            app_config.pop(\"acl_userlist\")\n\n    # Fetch old configuration\n    old_config = adaboard.request_adaboard(\n        path=f\"apps/{app_id}/\", method=requests.get\n    ).json()\n\n    # Build request payload combining new and old options\n    payload = {\n        k: v if v is not None else old_config[k] for k, v in app_config.items()\n    }\n\n    adaboard.request_adaboard(\n        path=f\"apps/{app_id}/\", method=requests.put, json=payload\n    )\n\n    return None\n</code></pre>"},{"location":"apps/#adalib.apps.get_all_apps","title":"get_all_apps","text":"<pre><code>get_all_apps()\n</code></pre> <p>Get information for all the apps deployed in AdaLab.</p> <p>Returns:</p> Type Description <code>list</code> <p>list with all the information of each app</p> Source code in <code>adalib/apps/apps.py</code> <pre><code>def get_all_apps() -&gt; (\n    list[dict[str, str | int | bool | dict[str, str] | list[str]]]\n):\n    \"\"\"Get information for all the apps deployed in AdaLab.\n\n    :return: list with all the information of each app\n    :rtype: list\n    \"\"\"\n\n    response = adaboard.request_adaboard(\n        path=\"apps/?all=true\", method=requests.get\n    ).json()\n\n    return response\n</code></pre>"},{"location":"apps/#adalib.apps.get_app","title":"get_app","text":"<pre><code>get_app(app_id)\n</code></pre> <p>Get the information of a specific deployed app in AdaLab.</p> <p>Parameters:</p> Name Type Description Default <code>app_id</code> <code>str</code> <p>the app's ID</p> required <p>Returns:</p> Type Description <code>dict</code> <p>app's information</p> Source code in <code>adalib/apps/apps.py</code> <pre><code>def get_app(\n    app_id: str,\n) -&gt; dict[str, str | int | bool | dict[str, str] | list[str]]:\n    \"\"\"Get the information of a specific deployed app in AdaLab.\n\n    :param app_id: the app's ID\n    :type app_id: str\n    :return: app's information\n    :rtype: dict\n    \"\"\"\n\n    response = adaboard.request_adaboard(\n        path=f\"apps/{app_id}/\", method=requests.get\n    ).json()\n\n    return response\n</code></pre>"},{"location":"apps/#adalib.apps.get_app_id","title":"get_app_id","text":"<pre><code>get_app_id(app_name='', author_id='', app_url='')\n</code></pre> <p>Get the ID of a deployed app in AdaLab. Either app_url, or app_name and author_id, must be specified.</p> <p>Parameters:</p> Name Type Description Default <code>app_name</code> <code>str</code> <p>name of the app, defaults to \"\"</p> <code>''</code> <code>author_id</code> <code>str</code> <p>author of the app, defaults to \"\"</p> <code>''</code> <code>app_url</code> <code>str</code> <p>endpoint of the app's URL, defaults to \"\"</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>the app's ID</p> Source code in <code>adalib/apps/apps.py</code> <pre><code>def get_app_id(\n    app_name: str = \"\", author_id: str = \"\", app_url: str = \"\"\n) -&gt; str:\n    \"\"\"Get the ID of a deployed app in AdaLab. Either app_url, or app_name and author_id, must be specified.\n\n    :param app_name: name of the app, defaults to \"\"\n    :type app_name: str, optional\n    :param author_id: author of the app, defaults to \"\"\n    :type author_id: str, optional\n    :param app_url: endpoint of the app's URL, defaults to \"\"\n    :type app_url: str, optional\n    :return: the app's ID\n    :rtype: str\n    \"\"\"\n\n    # Check that enough information is provided to find the app\n    assert (\n        app_name and author_id\n    ) or app_url, (\n        \"Either app_url, or app_name and author_id, must be specified.\"\n    )\n\n    # Get the list of all apps\n    response = adaboard.request_adaboard(\n        path=\"apps/?all=true\", method=requests.get\n    ).json()\n\n    # Return the ID of the requested app\n    try:\n        if app_url:\n            return [\n                app[\"app_id\"]\n                for app in response\n                if app[\"url_path_prefix\"] == app_url\n            ][0]\n        else:\n            return [\n                app[\"app_id\"]\n                for app in response\n                if app[\"name\"] == app_name and app[\"user_id\"] == author_id\n            ][0]\n    except IndexError:\n        raise ValueError(\"No app found with the specified parameters.\")\n</code></pre>"},{"location":"apps/#adalib.apps.get_app_logs","title":"get_app_logs","text":"<pre><code>get_app_logs(app_id, system=False)\n</code></pre> <p>Get the execution or deployment logs of a deployed app in AdaLab.</p> <p>Parameters:</p> Name Type Description Default <code>app_id</code> <code>str</code> <p>the app's ID</p> required <code>system</code> <code>bool</code> <p>whether to get the system logs or the deployment logs, defaults to False</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>deployment logs</p> Source code in <code>adalib/apps/apps.py</code> <pre><code>def get_app_logs(\n    app_id: str, system: bool = False\n) -&gt; str | list[dict[str, str]]:\n    \"\"\"Get the execution or deployment logs of a deployed app in AdaLab.\n\n    :param app_id: the app's ID\n    :type app_id: str\n    :param system: whether to get the system logs or the deployment logs, defaults to False\n    :type system: bool, optional\n    :return: deployment logs\n    :rtype: str\n    \"\"\"\n\n    response = adaboard.request_adaboard(\n        path=f\"apps/{app_id}/logs/?system={system}\", method=requests.get\n    ).json()\n\n    if system:\n        return response\n    else:\n        return response[\"log\"]\n</code></pre>"},{"location":"apps/#adalib.apps.get_apps_by_author","title":"get_apps_by_author","text":"<pre><code>get_apps_by_author(author_id)\n</code></pre> <p>Get information for all the apps deployed in AdaLab by a specific author.</p> <p>Parameters:</p> Name Type Description Default <code>author_id</code> <code>str</code> <p>the ID of the app's author</p> required <p>Returns:</p> Type Description <code>list</code> <p>list with all the information of each app</p> Source code in <code>adalib/apps/apps.py</code> <pre><code>def get_apps_by_author(\n    author_id: str,\n) -&gt; list[dict[str, str | int | bool | dict[str, str] | list[str]]]:\n    \"\"\"Get information for all the apps deployed in AdaLab by a specific author.\n\n    :param author_id: the ID of the app's author\n    :type author_id: str\n    :return: list with all the information of each app\n    :rtype: list\n    \"\"\"\n\n    response = adaboard.request_adaboard(\n        path=\"apps/?all=true\", method=requests.get\n    ).json()\n\n    return [app for app in response if app[\"user_id\"] == author_id]\n</code></pre>"},{"location":"apps/#adalib.apps.get_apps_status","title":"get_apps_status","text":"<pre><code>get_apps_status()\n</code></pre> <p>Get the status of all the apps deployed in AdaLab.</p> <p>Returns:</p> Type Description <code>dict</code> <p>dictionary with the status of each app</p> Source code in <code>adalib/apps/apps.py</code> <pre><code>def get_apps_status() -&gt; dict[str, str]:\n    \"\"\"Get the status of all the apps deployed in AdaLab.\n\n    :return: dictionary with the status of each app\n    :rtype: dict\n    \"\"\"\n\n    # Get status report for all apps\n    response_stats = adaboard.request_adaboard(\n        path=\"apps/status/\", method=requests.get\n    ).json()\n\n    # Get list of all apps\n    response_apps = adaboard.request_adaboard(\n        path=\"apps/?all=true\", method=requests.get\n    ).json()\n\n    # Build dictionary with the status of each app\n    apps_status = [\n        {\n            \"name\": app[\"name\"],\n            \"author\": app[\"user_id\"],\n            \"URL\": app[\"url_path_prefix\"],\n            \"status\": response_stats[str(app[\"status\"])],\n        }\n        for app in response_apps\n    ]\n    return apps_status\n</code></pre>"},{"location":"apps/#adalib.apps.restart_app","title":"restart_app","text":"<pre><code>restart_app(app_id)\n</code></pre> <p>Restart a deployed app in AdaLab.</p> <p>Parameters:</p> Name Type Description Default <code>app_id</code> <code>str</code> <p>the app's ID</p> required <p>Returns:</p> Type Description <code>None</code> <p>nothing</p> Source code in <code>adalib/apps/apps.py</code> <pre><code>def restart_app(app_id: str) -&gt; None:\n    \"\"\"Restart a deployed app in AdaLab.\n\n    :param app_id: the app's ID\n    :type app_id: str\n    :return: nothing\n    :rtype: None\n    \"\"\"\n\n    adaboard.request_adaboard(\n        path=f\"apps/{app_id}/restart/\", method=requests.put\n    )\n    return None\n</code></pre>"},{"location":"apps/#adalib.apps.start_app","title":"start_app","text":"<pre><code>start_app(app_id)\n</code></pre> <p>Start a deployed app in AdaLab.</p> <p>Parameters:</p> Name Type Description Default <code>app_id</code> <code>str</code> <p>the app's ID</p> required <p>Returns:</p> Type Description <code>None</code> <p>nothing</p> Source code in <code>adalib/apps/apps.py</code> <pre><code>def start_app(app_id: str) -&gt; None:\n    \"\"\"Start a deployed app in AdaLab.\n\n    :param app_id: the app's ID\n    :type app_id: str\n    :return: nothing\n    :rtype: None\n    \"\"\"\n\n    adaboard.request_adaboard(\n        path=f\"apps/{app_id}/start/\", method=requests.put\n    )\n\n    return None\n</code></pre>"},{"location":"apps/#adalib.apps.stop_app","title":"stop_app","text":"<pre><code>stop_app(app_id)\n</code></pre> <p>Stop a deployed app in AdaLab.</p> <p>Parameters:</p> Name Type Description Default <code>app_id</code> <code>str</code> <p>the app's ID</p> required <p>Returns:</p> Type Description <code>None</code> <p>nothing</p> Source code in <code>adalib/apps/apps.py</code> <pre><code>def stop_app(app_id: str) -&gt; None:\n    \"\"\"Stop a deployed app in AdaLab.\n\n    :param app_id: the app's ID\n    :type app_id: str\n    :return: nothing\n    :rtype: None\n    \"\"\"\n\n    adaboard.request_adaboard(path=f\"apps/{app_id}/stop/\", method=requests.put)\n    return None\n</code></pre>"},{"location":"cards/","title":"<code>adalib.cards</code>","text":"<p>The Cards sub-package exposes the core integrations of the cards in the AdaLab Gallery.</p>"},{"location":"cards/#adalib.cards-functions","title":"Functions","text":""},{"location":"cards/#adalib.cards.approve_card","title":"approve_card","text":"<pre><code>approve_card(card_id)\n</code></pre> <p>Approve and un-hide a specific card in the Gallery.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>int</code> <p>the id of the card to be approved</p> required <p>Returns:</p> Type Description <code>None</code> <p>Nothing</p> Source code in <code>adalib/cards/cards.py</code> <pre><code>def approve_card(card_id: int) -&gt; None | str:\n    \"\"\"\n    Approve and un-hide a specific card in the Gallery.\n\n    :param card_id: the id of the card to be approved\n    :type card_id: int\n    :return: Nothing\n    :rtype: None\n    \"\"\"\n\n    adaboard.request_adaboard(\n        path=f\"cards/{card_id}/approval\",\n        method=requests.put,\n    )\n\n    return None\n</code></pre>"},{"location":"cards/#adalib.cards.create_card","title":"create_card","text":"<pre><code>create_card(name, description, cardtype, notebook_file, acl_type_view='public', acl_list_view=[], acl_type_launch='public', acl_list_launch=[], acl_type_edit='public', acl_list_edit=[], aux_files=[{'source': '', 'target': ''}], coauthors=[], image_id=0, include_kernel=True, keywords=[], source='lab')\n</code></pre> <p>Create a card in the AdaLab Gallery. Note that only Notebook and Voil\u00e0 cards are supported.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the card</p> required <code>description</code> <code>str</code> <p>the card description (tip: supports Markdown)</p> required <code>cardtype</code> <code>str</code> <p>the type of card (tip: must be \"notebook\" or \"voila\")</p> required <code>notebook_file</code> <code>str</code> <p>the path to the main notebook file to be added to the card</p> required <code>acl_type_view</code> <code>str</code> <p>the ACL type for viewing the card, defaults to \"public\" (tip: must be \"public\", \"logged_in\", \"userlist\" or \"grouplist\")</p> <code>'public'</code> <code>acl_list_view</code> <code>list[str]</code> <p>the list of users/groups allowed to view the card, defaults to []</p> <code>[]</code> <code>acl_type_launch</code> <code>str</code> <p>the ACL type for launching the card, defaults to \"public\" (tip: must be \"public\", \"logged_in\", \"userlist\" or \"grouplist\")</p> <code>'public'</code> <code>acl_list_launch</code> <code>list[str]</code> <p>the list of users/groups allowed to launch the card, defaults to []</p> <code>[]</code> <code>acl_type_edit</code> <code>str</code> <p>the ACL type for editing the card, defaults to \"public\" (tip: must be \"public\", \"logged_in\", \"userlist\" or \"grouplist\")</p> <code>'public'</code> <code>acl_list_edit</code> <code>list[str]</code> <p>the list of users/groups allowed to edit the card, defaults to []</p> <code>[]</code> <code>aux_files</code> <code>list[dict[str, str]]</code> <p>the list of paths to the auxiliary files to be added to the card, defaults to {}</p> <code>[{'source': '', 'target': ''}]</code> <code>coauthors</code> <code>list[str]</code> <p>the other card authors, defaults to []</p> <code>[]</code> <code>image_id</code> <code>int</code> <p>the ID of the image to be used for the card, defaults to 0</p> <code>0</code> <code>include_kernel</code> <code>bool</code> <p>whether to link the Notebook with the kernel used during its development, defaults to True</p> <code>True</code> <code>keywords</code> <code>list[str]</code> <p>the keywords related to the card, defaults to [] (tip: must exist in the Gallery)</p> <code>[]</code> <code>source</code> <code>str</code> <p>the source of the card files, defaults to \"lab\" (tip: must be \"lab\" or \"local\")</p> <code>'lab'</code> <p>Returns:</p> Type Description <code>int</code> <p>the ID of the card</p> Source code in <code>adalib/cards/cards.py</code> <pre><code>def create_card(  # noqa: C901\n    name: str,\n    description: str,\n    cardtype: str,\n    notebook_file: str,\n    acl_type_view: str = \"public\",\n    acl_list_view: list[str] = [],\n    acl_type_launch: str = \"public\",\n    acl_list_launch: list[str] = [],\n    acl_type_edit: str = \"public\",\n    acl_list_edit: list[str] = [],\n    aux_files: list[dict[str, str]] = [{\"source\": \"\", \"target\": \"\"}],\n    coauthors: list[str] = [],\n    image_id: int = 0,\n    include_kernel: bool = True,\n    keywords: list[str] = [],\n    source: str = \"lab\",\n) -&gt; int:\n    \"\"\"Create a card in the AdaLab Gallery. Note that only Notebook and Voil\u00e0 cards are supported.\n\n    :param name: the name of the card\n    :type name: str\n    :param description: the card description (tip: supports Markdown)\n    :type description: str\n    :param cardtype: the type of card (tip: must be \"notebook\" or \"voila\")\n    :type cardtype: str\n    :param notebook_file: the path to the main notebook file to be added to the card\n    :type notebook_file: str\n    :param acl_type_view: the ACL type for viewing the card, defaults to \"public\" (tip: must be \"public\", \"logged_in\", \"userlist\" or \"grouplist\")\n    :type acl_type_view: str, optional\n    :param acl_list_view: the list of users/groups allowed to view the card, defaults to []\n    :type acl_list_view: list, optional\n    :param acl_type_launch: the ACL type for launching the card, defaults to \"public\" (tip: must be \"public\", \"logged_in\", \"userlist\" or \"grouplist\")\n    :type acl_type_launch: str, optional\n    :param acl_list_launch: the list of users/groups allowed to launch the card, defaults to []\n    :type acl_list_launch: list, optional\n    :param acl_type_edit: the ACL type for editing the card, defaults to \"public\" (tip: must be \"public\", \"logged_in\", \"userlist\" or \"grouplist\")\n    :type acl_type_edit: str, optional\n    :param acl_list_edit: the list of users/groups allowed to edit the card, defaults to []\n    :type acl_list_edit: list, optional\n    :param aux_files: the list of paths to the auxiliary files to be added to the card, defaults to {}\n    :type aux_files: dict, optional\n    :param coauthors: the other card authors, defaults to []\n    :type coauthors: list, optional\n    :param image_id: the ID of the image to be used for the card, defaults to 0\n    :type image_id: int, optional\n    :param include_kernel: whether to link the Notebook with the kernel used during its development, defaults to True\n    :type include_kernel: bool, optional\n    :param keywords: the keywords related to the card, defaults to [] (tip: must exist in the Gallery)\n    :type keywords: list, optional\n    :param source: the source of the card files, defaults to \"lab\" (tip: must be \"lab\" or \"local\")\n    :type source: str, optional\n    :return: the ID of the card\n    :rtype: int\n    \"\"\"\n\n    assert (\n        cardtype.lower() in ALLOWED_CARD_TYPES\n    ), \"Card type must be 'notebook' or 'voila'.\"\n    assert notebook_file.lower().endswith(\n        \".ipynb\"\n    ), \"Notebook file must be a .ipynb file.\"\n    assert (\n        source.lower() in ALLOWED_CARD_SOURCES\n    ), \"Files source must be 'lab' or 'local'.\"\n    assert (\n        acl_type_view.lower() in ALLOWED_ACL_TYPES\n    ), \"ACL type must be 'public', 'logged_in', 'userlist' or 'grouplist'.\"\n    assert (\n        acl_type_launch.lower() in ALLOWED_ACL_TYPES\n    ), \"ACL type must be 'public', 'logged_in', 'userlist' or 'grouplist'.\"\n    assert (\n        acl_type_edit.lower() in ALLOWED_ACL_TYPES\n    ), \"ACL type must be 'public', 'logged_in', 'userlist' or 'grouplist'.\"\n    assert all(\n        issubclass(type(x), dict) for x in aux_files\n    ), \"Auxiliary files must be a list of dictionaries.\"\n    assert all(\n        (\"source\" in d and \"target\" in d) for d in aux_files\n    ), \"Auxiliary files must have keys 'source' and 'target'.\"\n\n    cardtype_id = ALLOWED_CARD_TYPES[cardtype.lower()]\n\n    keywords_id = []\n    try:\n        if keywords:\n            response_kws = adaboard.request_adaboard(\n                path=\"keywords\",\n                method=requests.get,\n            ).json()\n            kws_list = [x[\"keyword\"] for x in response_kws]\n            ids_list = [x[\"keyword_id\"] for x in response_kws]\n            for kw in keywords:\n                idx = kws_list.index(kw)\n                keywords_id.append(ids_list[idx])\n    except ValueError as e:\n        raise ValueError(\n            f\"Keyword '{kw}' not found in the Gallery. Please add it first.\"\n        ) from e\n\n    # Main notebook file; read binary from Lab or local machine\n    if source.lower() == \"lab\":\n        # Check file size before actually pulling it from the Lab\n        try:\n            response_props = adaboard.request_adaboard(\n                path=f\"jupyter/files/notebook/content/?path={os.path.dirname(notebook_file)}\"\n            ).json()\n            props = [\n                x\n                for x in response_props\n                if x[\"name\"] == os.path.basename(notebook_file)\n            ][0]\n        except IndexError as e:\n            raise IndexError(\n                f\"Notebook file '{notebook_file}' not found in the Lab.\"\n            ) from e\n        assert (\n            props[\"size\"] &lt;= MAX_FILE_SIZE\n        ), f\"Notebook file size exceeds the maximum allowed ({MAX_FILE_SIZE} bytes). Please reduce the size of the file and try again.\"\n        nb_file_bin = adaboard.request_adaboard(\n            path=f\"jupyter/files/notebook/content/fetch?path={notebook_file}\",\n        ).json()[\"content\"]\n    else:\n        # Check file size before actually opening it\n        assert (\n            os.path.getsize(notebook_file) &lt;= MAX_FILE_SIZE\n        ), f\"Notebook file size exceeds the maximum allowed ({MAX_FILE_SIZE} bytes). Please reduce the size of the file and try again.\"\n        with open(notebook_file, \"rb\") as f:\n            nb_file_bin = base64.b64encode(f.read()).decode(\"utf-8\")\n\n    if not include_kernel:\n        nb_file_dict = json.loads(\n            base64.b64decode(nb_file_bin).decode(\"utf-8\")\n        )\n        nb_file_dict[\"metadata\"][\"kernelspec\"] = {\n            \"display_name\": \"\",\n            \"name\": \"\",\n        }\n        nb_file_bin = base64.b64encode(\n            json.dumps(nb_file_dict).encode(\"utf-8\")\n        ).decode(\"utf-8\")\n\n    content = [\n        {\n            \"content\": nb_file_bin,\n            \"content_name\": os.path.basename(notebook_file),\n            \"contenttype_id\": 1,\n            \"path\": notebook_file if source.lower() == \"lab\" else None,\n        }\n    ]\n\n    # Auxiliary files\n    # Collect all files within the specified paths\n    if aux_files[0][\"source\"]:\n        # In the Lab, paths are relative to the user's home directory\n        if source.lower() == \"lab\":\n            # Collect all files within the specified paths\n            all_aux_files = []\n            for aux_file in aux_files:\n                # Directories end with \"/\"; otherwise they are considered files; no nesting allowed\n                if aux_file[\"source\"].endswith(\"/\"):\n                    dir_cont = adaboard.request_adaboard(\n                        path=f\"jupyter/files/notebook/content/?path={aux_file['source']}\"\n                    ).json()\n                    dir_paths = [\n                        {\n                            \"source\": x[\"path\"],\n                            \"target\": aux_file[\"target\"],\n                            \"size\": x[\"size\"],\n                        }\n                        for x in dir_cont\n                        if x[\"type\"] == \"file\"\n                    ]\n                    all_aux_files.extend(dir_paths)\n                else:\n                    response_props = adaboard.request_adaboard(\n                        path=f\"jupyter/files/notebook/content/?path={os.path.dirname(aux_file['source'])}\"\n                    ).json()\n                    file_path = [\n                        {\n                            \"source\": x[\"path\"],\n                            \"target\": aux_file[\"target\"],\n                            \"size\": x[\"size\"],\n                        }\n                        for x in response_props\n                        if x[\"name\"] == os.path.basename(aux_file[\"source\"])\n                    ]\n                    all_aux_files.extend(file_path)\n            # Now we have all the files with their paths and sizes in a single list\n            for aux_file in all_aux_files:\n                # Check file size before actually pulling it from the Lab\n                assert (\n                    aux_file[\"size\"] &lt;= MAX_FILE_SIZE\n                ), f\"Auxiliary file size exceeds the maximum allowed ({MAX_FILE_SIZE} bytes). Please reduce the size of the file and try again.\"\n                # \"content\" is the binary; \"content_name\" determines the target folder\n                aux_file_bin = adaboard.request_adaboard(\n                    path=f\"jupyter/files/notebook/content/fetch?path={aux_file['source']}\",\n                ).json()[\"content\"]\n                aux_file_name = f\"{aux_file['target']}{os.path.basename(aux_file['source'])}\"\n                tmp = {\n                    \"content\": aux_file_bin,\n                    \"content_name\": aux_file_name,\n                    \"contenttype_id\": 2,\n                    \"path\": aux_file[\"source\"],\n                }\n                content.append(tmp)\n\n        # In the local machine, paths are absolute; nesting is allowed\n        elif source.lower() == \"local\":\n            all_aux_files = []\n            for aux_file in aux_files:\n                if os.path.isfile(aux_file[\"source\"]):\n                    all_aux_files.append(aux_file)\n                elif os.path.isdir(aux_file[\"source\"]):\n                    for root, dirs, files in os.walk(aux_file[\"source\"]):\n                        for file in files:\n                            all_aux_files.append(\n                                {\n                                    \"source\": f\"{root}/{file}\",\n                                    \"target\": f\"{root}/\".replace(\n                                        aux_file[\"source\"], aux_file[\"target\"]\n                                    ),\n                                }\n                            )\n            # Now we have all the files with their paths in a single list\n            for aux_file in all_aux_files:\n                # Check file sizes before actually opening them\n                assert (\n                    os.path.getsize(aux_file[\"source\"]) &lt;= MAX_FILE_SIZE\n                ), f\"Auxiliary file size exceeds the maximum allowed ({MAX_FILE_SIZE} bytes). Please reduce the size of the file and try again.\"\n                with open(aux_file[\"source\"], \"rb\") as f:\n                    aux_file_bin = base64.b64encode(f.read()).decode(\"utf-8\")\n                # \"content\" is the binary; \"content_name\" determines the target folder\n                aux_file_name = f\"{aux_file['target']}/{os.path.basename(aux_file['source'])}\"\n                tmp = {\n                    \"content\": aux_file_bin,\n                    \"content_name\": aux_file_name,\n                    \"contenttype_id\": 2,\n                }\n                content.append(tmp)\n\n    acl_config = [\n        {\n            \"acl_action\": \"card_view\",\n            \"acl_type\": acl_type_view if acl_type_view else \"public\",\n            \"userlist\": acl_list_view if acl_type_view == \"userlist\" else [],\n            \"grouplist\": acl_list_view if acl_type_view == \"grouplist\" else [],\n        },\n        {\n            \"acl_action\": \"card_launch\",\n            \"acl_type\": acl_type_launch if acl_type_launch else \"public\",\n            \"userlist\": (\n                acl_list_launch if acl_type_launch == \"userlist\" else []\n            ),\n            \"grouplist\": (\n                acl_list_launch if acl_type_launch == \"grouplist\" else []\n            ),\n        },\n        {\n            \"acl_action\": \"card_edit\",\n            \"acl_type\": acl_type_edit if acl_type_edit else \"public\",\n            \"userlist\": acl_list_edit if acl_type_edit == \"userlist\" else [],\n            \"grouplist\": acl_list_edit if acl_type_edit == \"grouplist\" else [],\n        },\n    ]\n    payload = {\n        \"name\": name,\n        \"description\": description,\n        \"cardtype_id\": cardtype_id,\n        \"author_id\": adaboard.get_user()[\"user_id\"],\n        \"owner_id\": adaboard.get_user()[\"user_id\"],\n        \"image_id\": image_id,\n        \"keywords\": keywords_id,\n        \"coauthors\": coauthors,\n        \"acls\": acl_config,\n        \"content\": content,\n    }\n\n    response = adaboard.request_adaboard(\n        path=\"cards\",\n        method=requests.post,\n        json=payload,\n    ).json()\n\n    return response[\"id\"]\n</code></pre>"},{"location":"cards/#adalib.cards.delete_card","title":"delete_card","text":"<pre><code>delete_card(card_id)\n</code></pre> <p>Delete a card from the Gallery.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>int</code> <p>the id of the card to be deleted</p> required <p>Returns:</p> Type Description <code>None</code> <p>Nothing</p> Source code in <code>adalib/cards/cards.py</code> <pre><code>def delete_card(card_id: int) -&gt; None | str:\n    \"\"\"\n    Delete a card from the Gallery.\n\n    :param card_id: the id of the card to be deleted\n    :type card_id: int\n    :return: Nothing\n    :rtype: None\n    \"\"\"\n\n    adaboard.request_adaboard(\n        path=f\"cards/{card_id}\",\n        method=requests.delete,\n    )\n\n    return None\n</code></pre>"},{"location":"cards/#adalib.cards.deregister_as_reviewer","title":"deregister_as_reviewer","text":"<pre><code>deregister_as_reviewer(card_id)\n</code></pre> <p>De-register invoker as card reviewer.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>int</code> <p>the id of the card for which the user will stop being the reviewer</p> required <p>Returns:</p> Type Description <code>None</code> <p>Nothing</p> Source code in <code>adalib/cards/cards.py</code> <pre><code>def deregister_as_reviewer(card_id: int) -&gt; None | str:\n    \"\"\"\n    De-register invoker as card reviewer.\n\n    :param card_id: the id of the card for which the user will stop being the reviewer\n    :type card_id: int\n    :return: Nothing\n    :rtype: None\n    \"\"\"\n\n    adaboard.request_adaboard(\n        path=f\"cards/{card_id}/reviewer\",\n        method=requests.delete,\n    )\n\n    return None\n</code></pre>"},{"location":"cards/#adalib.cards.edit_card","title":"edit_card","text":"<pre><code>edit_card(card_id, name=None, description=None, cardtype=None, notebook_file=None, acl_type_view=None, acl_list_view=None, acl_type_launch=None, acl_list_launch=None, acl_type_edit=None, acl_list_edit=None, aux_files=None, coauthors=None, image_id=None, keywords=None, source='lab', keep_aux_files=True)\n</code></pre> <p>Edit a card in the AdaLab Gallery. Note that unspecified fields will not be changed.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>int</code> <p>the ID of the card</p> required <code>name</code> <code>str</code> <p>the new name of the card</p> <code>None</code> <code>description</code> <code>str</code> <p>the new description of the card (tip: supports Markdown)</p> <code>None</code> <code>cardtype</code> <code>str</code> <p>the type of card (tip: must be \"notebook\" or \"voila\")</p> <code>None</code> <code>notebook_file</code> <code>str</code> <p>the path to the new main notebook file to be added to the card</p> <code>None</code> <code>acl_type_view</code> <code>str</code> <p>the ACL type for viewing the card (tip: must be \"public\", \"logged_in\", \"userlist\" or \"grouplist\")</p> <code>None</code> <code>acl_list_view</code> <code>list[str]</code> <p>the list of users/groups allowed to view the card</p> <code>None</code> <code>acl_type_launch</code> <code>str</code> <p>the ACL type for launching the card (tip: must be \"public\", \"logged_in\", \"userlist\" or \"grouplist\")</p> <code>None</code> <code>acl_list_launch</code> <code>list[str]</code> <p>the list of users/groups allowed to launch the card</p> <code>None</code> <code>acl_type_edit</code> <code>str</code> <p>the ACL type for editing the card (tip: must be \"public\", \"logged_in\", \"userlist\" or \"grouplist\")</p> <code>None</code> <code>acl_list_edit</code> <code>list[str]</code> <p>the list of users/groups allowed to edit the card</p> <code>None</code> <code>aux_files</code> <code>dict[str, str]</code> <p>the list of paths to the new auxiliary files to be added to the card</p> <code>None</code> <code>coauthors</code> <code>list[str]</code> <p>the other card authors</p> <code>None</code> <code>image_id</code> <code>int</code> <p>the ID of the image to be used for the card</p> <code>None</code> <code>keywords</code> <code>list[str]</code> <p>the keywords related to the card, defaults to [] (tip: must exist in the Gallery)</p> <code>None</code> <code>source</code> <code>str</code> <p>the source of the card files, defaults to \"lab\" (tip: must be \"lab\" or \"local\")</p> <code>'lab'</code> <code>keep_aux_files</code> <code>bool</code> <p>whether to keep the existing auxiliary files or not, defaults to True</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>nothing</p> Source code in <code>adalib/cards/cards.py</code> <pre><code>def edit_card(  # noqa: C901\n    card_id: int,\n    name: str = None,\n    description: str = None,\n    cardtype: str = None,\n    notebook_file: str = None,\n    acl_type_view: str = None,\n    acl_list_view: list[str] = None,\n    acl_type_launch: str = None,\n    acl_list_launch: list[str] = None,\n    acl_type_edit: str = None,\n    acl_list_edit: list[str] = None,\n    aux_files: dict[str, str] = None,\n    coauthors: list[str] = None,\n    image_id: int = None,\n    keywords: list[str] = None,\n    source: str = \"lab\",\n    keep_aux_files: bool = True,\n) -&gt; None:\n    \"\"\"Edit a card in the AdaLab Gallery. Note that unspecified fields will not be changed.\n\n    :param card_id: the ID of the card\n    :type card_id: int\n    :param name: the new name of the card\n    :type name: str, optional\n    :param description: the new description of the card (tip: supports Markdown)\n    :type description: str, optional\n    :param cardtype: the type of card (tip: must be \"notebook\" or \"voila\")\n    :type cardtype: str, optional\n    :param notebook_file: the path to the new main notebook file to be added to the card\n    :type notebook_file: str, optional\n    :param acl_type_view: the ACL type for viewing the card (tip: must be \"public\", \"logged_in\", \"userlist\" or \"grouplist\")\n    :type acl_type_view: str, optional\n    :param acl_list_view: the list of users/groups allowed to view the card\n    :type acl_list_view: list, optional\n    :param acl_type_launch: the ACL type for launching the card (tip: must be \"public\", \"logged_in\", \"userlist\" or \"grouplist\")\n    :type acl_type_launch: str, optional\n    :param acl_list_launch: the list of users/groups allowed to launch the card\n    :type acl_list_launch: list, optional\n    :param acl_type_edit: the ACL type for editing the card (tip: must be \"public\", \"logged_in\", \"userlist\" or \"grouplist\")\n    :type acl_type_edit: str, optional\n    :param acl_list_edit: the list of users/groups allowed to edit the card\n    :type acl_list_edit: list, optional\n    :param aux_files: the list of paths to the new auxiliary files to be added to the card\n    :type aux_files: dict, optional\n    :param coauthors: the other card authors\n    :type coauthors: list, optional\n    :param image_id: the ID of the image to be used for the card\n    :type image_id: int, optional\n    :param keywords: the keywords related to the card, defaults to [] (tip: must exist in the Gallery)\n    :type keywords: list, optional\n    :param source: the source of the card files, defaults to \"lab\" (tip: must be \"lab\" or \"local\")\n    :type source: str, optional\n    :param keep_aux_files: whether to keep the existing auxiliary files or not, defaults to True\n    :type keep_aux_files: bool, optional\n    :return: nothing\n    :rtype: None\n    \"\"\"\n    assert (\n        cardtype is None or cardtype.lower() in ALLOWED_CARD_TYPES\n    ), \"Card type must be 'notebook' or 'voila'.\"\n    assert notebook_file is None or notebook_file.lower().endswith(\n        \".ipynb\"\n    ), \"Notebook file must be a .ipynb file.\"\n    assert (\n        source.lower() in ALLOWED_CARD_SOURCES\n    ), \"Files source must be 'lab' or 'local'.\"\n    assert (\n        acl_type_view is None or acl_type_view.lower() in ALLOWED_ACL_TYPES\n    ), \"ACL type must be 'public', 'logged_in', 'userlist' or 'grouplist'.\"\n    assert (\n        acl_type_launch is None or acl_type_launch.lower() in ALLOWED_ACL_TYPES\n    ), \"ACL type must be 'public', 'logged_in', 'userlist' or 'grouplist'.\"\n    assert (\n        acl_type_edit is None or acl_type_edit.lower() in ALLOWED_ACL_TYPES\n    ), \"ACL type must be 'public', 'logged_in', 'userlist' or 'grouplist'.\"\n    assert aux_files is None or all(\n        issubclass(type(x), dict) for x in aux_files\n    ), \"Auxiliary files must be a list of dictionaries.\"\n    assert aux_files is None or all(\n        (\"source\" in d and \"target\" in d) for d in aux_files\n    ), \"Auxiliary files must have keys 'source' and 'target'.\"\n\n    try:\n        cardtype_id = ALLOWED_CARD_TYPES[cardtype.lower()]\n    except AttributeError:\n        cardtype_id = None\n    keywords_id = []\n    try:\n        if keywords:\n            response_kws = adaboard.request_adaboard(\n                path=\"keywords\",\n                method=requests.get,\n            ).json()\n            kws_list = [x[\"keyword\"] for x in response_kws]\n            ids_list = [x[\"keyword_id\"] for x in response_kws]\n            for kw in keywords:\n                idx = kws_list.index(kw)\n                keywords_id.append(ids_list[idx])\n    except ValueError as e:\n        raise ValueError(\n            f\"Keyword '{kw}' not found in the Gallery. Please add it first.\"\n        ) from e\n\n    # Collect new configuration options\n    card_config = {\n        \"name\": name,\n        \"description\": description,\n        \"cardtype_id\": cardtype_id,\n        \"author_id\": None,\n        \"owner_id\": None,\n        \"image_id\": image_id,\n        \"keywords\": keywords_id,\n        \"coauthors\": coauthors,\n        \"acls\": None,\n        \"content\": None,\n    }\n    # Fetch old configuration\n    old_config = adaboard.request_adaboard(\n        path=f\"cards/{card_id}\", method=requests.get\n    ).json()\n\n    # ACLs need to be re-formatted for the PUT request\n    old_acls = []\n    for tmp in old_config[\"acls\"]:\n        if tmp[\"acl_type\"] == \"grouplist\":\n            tmp[\"grouplist\"] = [x[\"group_id\"] for x in tmp[\"grouplist\"]]\n        elif tmp[\"acl_type\"] == \"userlist\":\n            tmp[\"userlist\"] = [x[\"user_id\"] for x in tmp[\"userlist\"]]\n        else:\n            tmp[\"grouplist\"] = []\n            tmp[\"userlist\"] = []\n        old_acls.append(tmp)\n    old_config[\"acls\"] = old_acls\n    # Collect the new ACLs\n    acl_config = [\n        {\n            \"acl_action\": \"card_view\",\n            \"acl_type\": (\n                acl_type_view\n                if acl_type_view\n                else old_config[\"acls\"][0][\"acl_type\"]\n            ),\n            \"userlist\": (\n                acl_list_view\n                if acl_list_view\n                else old_config[\"acls\"][0][\"userlist\"]\n            ),\n            \"grouplist\": (\n                acl_list_view\n                if acl_list_view\n                else old_config[\"acls\"][0][\"grouplist\"]\n            ),\n        },\n        {\n            \"acl_action\": \"card_launch\",\n            \"acl_type\": (\n                acl_type_launch\n                if acl_type_launch\n                else old_config[\"acls\"][1][\"acl_type\"]\n            ),\n            \"userlist\": (\n                acl_list_launch\n                if acl_type_launch\n                else old_config[\"acls\"][1][\"userlist\"]\n            ),\n            \"grouplist\": (\n                acl_list_launch\n                if acl_type_launch\n                else old_config[\"acls\"][1][\"grouplist\"]\n            ),\n        },\n        {\n            \"acl_action\": \"card_edit\",\n            \"acl_type\": (\n                acl_type_edit\n                if acl_type_edit\n                else old_config[\"acls\"][2][\"acl_type\"]\n            ),\n            \"userlist\": (\n                acl_list_edit\n                if acl_type_edit\n                else old_config[\"acls\"][2][\"userlist\"]\n            ),\n            \"grouplist\": (\n                acl_list_edit\n                if acl_type_edit\n                else old_config[\"acls\"][2][\"grouplist\"]\n            ),\n        },\n    ]\n    card_config[\"acls\"] = acl_config\n    # Update content\n    # First, the main Notebook\n    if notebook_file:\n        if source.lower() == \"lab\":\n            # Check file size before actually pulling it from the Lab\n            try:\n                response_props = adaboard.request_adaboard(\n                    path=f\"jupyter/files/notebook/content/?path={os.path.dirname(notebook_file)}\"\n                ).json()\n                props = [\n                    x\n                    for x in response_props\n                    if x[\"name\"] == os.path.basename(notebook_file)\n                ][0]\n            except IndexError as e:\n                raise IndexError(\n                    f\"Notebook file '{notebook_file}' not found in the Lab.\"\n                ) from e\n            assert (\n                props[\"size\"] &lt;= MAX_FILE_SIZE\n            ), f\"Notebook file size exceeds the maximum allowed ({MAX_FILE_SIZE} bytes). Please reduce the size of the file and try again.\"\n            nb_file_bin = adaboard.request_adaboard(\n                path=f\"jupyter/files/notebook/content/fetch?path={notebook_file}\",\n            ).json()[\"content\"]\n        else:\n            # Check file size before actually opening it\n            assert (\n                os.path.getsize(notebook_file) &lt;= MAX_FILE_SIZE\n            ), f\"Notebook file size exceeds the maximum allowed ({MAX_FILE_SIZE} bytes). Please reduce the size of the file and try again.\"\n            with open(notebook_file, \"rb\") as f:\n                nb_file_bin = base64.b64encode(f.read()).decode(\"utf-8\")\n\n        content = [\n            {\n                \"content\": nb_file_bin,\n                \"content_name\": os.path.basename(notebook_file),\n                \"contenttype_id\": 1,\n                \"path\": notebook_file if source.lower() == \"lab\" else None,\n            }\n        ]\n    else:\n        content = [\n            x for x in old_config[\"content\"] if x[\"contenttype_id\"] == 1\n        ]\n\n    # Next, the auxiliary files\n    # Start by collecting or ditching the old ones\n    if keep_aux_files:\n        old_aux_files = [\n            x for x in old_config[\"content\"] if x[\"contenttype_id\"] == 2\n        ]\n        content.extend(old_aux_files)\n    # Then, add the new ones\n    if aux_files:\n        # In the Lab, paths are relative to the user's home directory\n        if source.lower() == \"lab\":\n            # Collect all files within the specified paths\n            all_aux_files = []\n            for aux_file in aux_files:\n                # Directories end with \"/\"; otherwise they are considered files; no nesting allowed\n                if aux_file[\"source\"].endswith(\"/\"):\n                    dir_cont = adaboard.request_adaboard(\n                        path=f\"jupyter/files/notebook/content/?path={aux_file['source']}\"\n                    ).json()\n                    dir_paths = [\n                        {\n                            \"source\": x[\"path\"],\n                            \"target\": aux_file[\"target\"],\n                            \"size\": x[\"size\"],\n                        }\n                        for x in dir_cont\n                        if x[\"type\"] == \"file\"\n                    ]\n                    all_aux_files.extend(dir_paths)\n                else:\n                    response_props = adaboard.request_adaboard(\n                        path=f\"jupyter/files/notebook/content/?path={os.path.dirname(aux_file['source'])}\"\n                    ).json()\n                    file_path = [\n                        {\n                            \"source\": x[\"path\"],\n                            \"target\": aux_file[\"target\"],\n                            \"size\": x[\"size\"],\n                        }\n                        for x in response_props\n                        if x[\"name\"] == os.path.basename(aux_file[\"source\"])\n                    ]\n                    all_aux_files.extend(file_path)\n            # Now we have all the files with their paths and sizes in a single list\n            for aux_file in all_aux_files:\n                # Check file size before actually pulling it from the Lab\n                assert (\n                    aux_file[\"size\"] &lt;= MAX_FILE_SIZE\n                ), f\"Auxiliary file size exceeds the maximum allowed ({MAX_FILE_SIZE} bytes). Please reduce the size of the file and try again.\"\n                # \"content\" is the binary; \"content_name\" determines the target folder\n                aux_file_bin = adaboard.request_adaboard(\n                    path=f\"jupyter/files/notebook/content/fetch?path={aux_file['source']}\",\n                ).json()[\"content\"]\n                aux_file_name = f\"{aux_file['target']}{os.path.basename(aux_file['source'])}\"\n                tmp = {\n                    \"content\": aux_file_bin,\n                    \"content_name\": aux_file_name,\n                    \"contenttype_id\": 2,\n                    \"path\": aux_file[\"source\"],\n                }\n                content.append(tmp)\n\n        # In the local machine, paths are absolute; nesting is allowed\n        elif source.lower() == \"local\":\n            all_aux_files = []\n            for aux_file in aux_files:\n                if os.path.isfile(aux_file[\"source\"]):\n                    all_aux_files.append(aux_file)\n                elif os.path.isdir(aux_file[\"source\"]):\n                    for root, dirs, files in os.walk(aux_file[\"source\"]):\n                        for file in files:\n                            all_aux_files.append(\n                                {\n                                    \"source\": f\"{root}/{file}\",\n                                    \"target\": f\"{root}/\".replace(\n                                        aux_file[\"source\"], aux_file[\"target\"]\n                                    ),\n                                }\n                            )\n            # Now we have all the files with their paths in a single list\n            for aux_file in all_aux_files:\n                # Check file sizes before actually opening them\n                assert (\n                    os.path.getsize(aux_file[\"source\"]) &lt;= MAX_FILE_SIZE\n                ), f\"Auxiliary file size exceeds the maximum allowed ({MAX_FILE_SIZE} bytes). Please reduce the size of the file and try again.\"\n                with open(aux_file[\"source\"], \"rb\") as f:\n                    aux_file_bin = base64.b64encode(f.read()).decode(\"utf-8\")\n                # \"content\" is the binary; \"content_name\" determines the target folder\n                aux_file_name = f\"{aux_file['target']}/{os.path.basename(aux_file['source'])}\"\n                tmp = {\n                    \"content\": aux_file_bin,\n                    \"content_name\": aux_file_name,\n                    \"contenttype_id\": 2,\n                }\n                content.append(tmp)\n\n    card_config[\"content\"] = content\n    # Build request payload combining new and old options\n    payload = {\n        k: v if v is not None else old_config[k]\n        for k, v in card_config.items()\n    }\n    adaboard.request_adaboard(\n        f\"cards/{card_id}\", method=requests.put, json=payload\n    )\n    return None\n</code></pre>"},{"location":"cards/#adalib.cards.expose_card","title":"expose_card","text":"<pre><code>expose_card(card_id)\n</code></pre> <p>Expose (un-hide) a specific card in the Gallery.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>int</code> <p>the id of the card to be exposed</p> required <p>Returns:</p> Type Description <code>None</code> <p>Nothing</p> Source code in <code>adalib/cards/cards.py</code> <pre><code>def expose_card(card_id: int) -&gt; None:\n    \"\"\"\n    Expose (un-hide) a specific card in the Gallery.\n\n    :param card_id: the id of the card to be exposed\n    :type card_id: int\n    :return: Nothing\n    :rtype: None\n    \"\"\"\n\n    set_card_visibility(\n        card_id=card_id,\n        new_status=\"exposed\",\n    )\n\n    return None\n</code></pre>"},{"location":"cards/#adalib.cards.get_card_contents","title":"get_card_contents","text":"<pre><code>get_card_contents(card_id)\n</code></pre> <p>Gets the contents of a specific card in the Gallery.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>int</code> <p>the id of the card to be fetched</p> required <p>Returns:</p> Type Description <code>dict</code> <p>a dictionary with the different fields in the card</p> Source code in <code>adalib/cards/cards.py</code> <pre><code>def get_card_contents(card_id: int) -&gt; dict[str, Union[str, list[dict]]]:\n    \"\"\"\n    Gets the contents of a specific card in the Gallery.\n\n    :param card_id: the id of the card to be fetched\n    :type card_id: int\n    :return: a dictionary with the different fields in the card\n    :rtype: dict\n    \"\"\"\n\n    response = adaboard.request_adaboard(path=f\"cards/{card_id}\").json()\n\n    return_struct = {\n        \"card_author\": response.get(\"author\").get(\"name\"),\n        \"card_name\": response.get(\"name\"),\n        \"description\": response.get(\"description\"),\n        \"card_type\": response.get(\"cardtype\").get(\"key\"),\n        \"contents\": [],\n    }\n\n    for contents in response.get(\"content\"):\n        content = base64.b64decode(contents.get(\"content\"))\n        contents[\"content\"] = content\n        return_struct.get(\"contents\").append(contents)\n\n    return return_struct\n</code></pre>"},{"location":"cards/#adalib.cards.get_card_issues","title":"get_card_issues","text":"<pre><code>get_card_issues(card_id)\n</code></pre> <p>Get the issues related to a specific card in the Gallery.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>int</code> <p>the id of the card whose issues are to be fetched</p> required <p>Returns:</p> Type Description <code>list</code> <p>list of dictionaries with issues content and metadata</p> Source code in <code>adalib/cards/cards.py</code> <pre><code>def get_card_issues(\n    card_id: int,\n) -&gt; list[dict[str, int | str | dict[str, str | int]]]:\n    \"\"\"\n    Get the issues related to a specific card in the Gallery.\n\n    :param card_id: the id of the card whose issues are to be fetched\n    :type card_id: int\n    :return: list of dictionaries with issues content and metadata\n    :rtype: list\n    \"\"\"\n\n    response = adaboard.request_adaboard(\n        path=f\"cards/{card_id}/issues\", method=requests.get\n    ).json()\n\n    return response\n</code></pre>"},{"location":"cards/#adalib.cards.get_card_types","title":"get_card_types","text":"<pre><code>get_card_types()\n</code></pre> <p>List all the card types in the Gallery and their main information.</p> <p>Returns:</p> Type Description <code>list</code> <p>list of card-types dictionaries</p> Source code in <code>adalib/cards/cards.py</code> <pre><code>def get_card_types() -&gt; list[dict[str, Union[int, str, bool]]]:\n    \"\"\"\n    List all the card types in the Gallery and their main information.\n\n    :return: list of card-types dictionaries\n    :rtype: list\n    \"\"\"\n\n    response = adaboard.request_adaboard(\n        path=\"cardtypes\",\n        method=requests.get,\n    ).json()\n\n    return response\n</code></pre>"},{"location":"cards/#adalib.cards.get_card_types_stats","title":"get_card_types_stats","text":"<pre><code>get_card_types_stats()\n</code></pre> <p>Get the statistics of the card types in the Gallery.</p> <p>Returns:</p> Type Description <code>list</code> <p>list of card-types-info dictionaries</p> Source code in <code>adalib/cards/cards.py</code> <pre><code>def get_card_types_stats() -&gt; list[dict[str, str | int]]:\n    \"\"\"\n    Get the statistics of the card types in the Gallery.\n\n    :return: list of card-types-info dictionaries\n    :rtype: list\n    \"\"\"\n    response = adaboard.request_adaboard(\n        path=\"cardtypes/statistics\", method=requests.get\n    ).json()\n\n    return response\n</code></pre>"},{"location":"cards/#adalib.cards.get_cards","title":"get_cards","text":"<pre><code>get_cards(card_type='all')\n</code></pre> <p>Gets all cards registered in the Gallery</p> <p>Parameters:</p> Name Type Description Default <code>card_type</code> <code>str</code> <p>The type of cards to return, defaults to \"all\". Available values are \"all\", \"notebook\", \"voila\", \"url\" and \"kernel\".</p> <code>'all'</code> <p>Returns:</p> Type Description <code>list</code> <p>a list with the main info of all cards in the Gallery</p> Source code in <code>adalib/cards/cards.py</code> <pre><code>def get_cards(card_type: str = \"all\") -&gt; list[list[int | str]]:\n    \"\"\"\n    Gets all cards registered in the Gallery\n\n    :param card_type: The type of cards to return, defaults to \"all\".\n    Available values are \"all\", \"notebook\", \"voila\", \"url\" and \"kernel\".\n    :type card_type: str\n    :return: a list with the main info of all cards in the Gallery\n    :rtype: list\n    \"\"\"\n    card_types = [\n        x.get(\"key\")\n        for x in adaboard.request_adaboard(path=\"cardtypes\").json()\n    ]\n    card_types.append(\"all\")\n    assert (\n        card_type in card_types\n    ), f\"Card type must be one of {', '.join(card_types)}\"\n    all_responses = []\n    page = 1\n    while True:\n        response = adaboard.request_adaboard(\n            path=f\"cards?page={page}&amp;size=50\",\n        ).json()\n        all_responses.extend(response.get(\"items\"))\n        if page == response[\"pages\"]:\n            break\n        page += 1\n    if card_type == \"all\":\n        return [\n            [\n                x.get(\"card_id\"),\n                x.get(\"cardtype\").get(\"key\"),\n                x.get(\"name\"),\n                x.get(\"author\").get(\"name\"),\n            ]\n            for x in all_responses\n        ]\n    return [\n        [\n            x.get(\"card_id\"),\n            x.get(\"cardtype\").get(\"key\"),\n            x.get(\"name\"),\n            x.get(\"author\").get(\"name\"),\n        ]\n        for x in all_responses\n        if x.get(\"cardtype\").get(\"key\") == card_type\n    ]\n</code></pre>"},{"location":"cards/#adalib.cards.hide_card","title":"hide_card","text":"<pre><code>hide_card(card_id)\n</code></pre> <p>Hide a specific card in the Gallery.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>int</code> <p>the id of the card to be hidden</p> required <p>Returns:</p> Type Description <code>None</code> <p>Nothing</p> Source code in <code>adalib/cards/cards.py</code> <pre><code>def hide_card(card_id: int) -&gt; None:\n    \"\"\"\n    Hide a specific card in the Gallery.\n\n    :param card_id: the id of the card to be hidden\n    :type card_id: int\n    :return: Nothing\n    :rtype: None\n    \"\"\"\n\n    set_card_visibility(card_id=card_id, new_status=\"hidden\")\n\n    return None\n</code></pre>"},{"location":"cards/#adalib.cards.launch_card","title":"launch_card","text":"<pre><code>launch_card(card_id, start_lab=True, lab_config={})\n</code></pre> <p>Launch a card from the Gallery into the user's Lab.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>int</code> <p>the ID of the card to be launched</p> required <code>start_lab</code> <code>bool</code> <p>whether to also start the Lab when launching the card, defaults to True. Note that the Lab must be stopped for this to have any effect</p> <code>True</code> <code>lab_config</code> <code>dict</code> <p>desired configuration for the Lab environment. It can be set up either passing the IDs of the values for each configuration type, or by choosing one of the user's Lab profiles. Defaults to None (i.e., uses the user's default Lab profile). Can</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>URL/path to Notebook file in the user's Lab</p> Source code in <code>adalib/cards/cards.py</code> <pre><code>def launch_card(\n    card_id: int, start_lab: bool = True, lab_config: dict = {}\n) -&gt; str:\n    \"\"\"\n    Launch a card from the Gallery into the user's Lab.\n\n    :param card_id: the ID of the card to be launched\n    :type card_id: int\n    :param start_lab: whether to also start the Lab when launching the card, defaults to True. Note that the Lab must be stopped for this to have any effect\n    :type start_lab: bool, optional\n    :param lab_config: desired configuration for the Lab environment. It can be set up either passing the IDs of the values for each configuration type, or by choosing one of the user's Lab profiles. Defaults to None (i.e., uses the user's default Lab profile). Can\n    :type lab_config: dict, optional\n    :return: URL/path to Notebook file in the user's Lab\n    :rtype: str\n    \"\"\"\n\n    # Check whether the chosen configuration is valid\n    if lab_config:\n        assert list(lab_config.keys()) == [\"options\"] or list(\n            lab_config.keys()\n        ) == [\n            \"profile_id\"\n        ], \"Configuration must be a list of IDs with key 'options', or a value with key 'profile_id'.\"\n        if list(lab_config.keys()) == [\"options\"]:\n            config_opts = adaboard.request_adaboard(\n                path=\"jupyter/system/options\"\n            ).json()\n            tmp = []\n            for item in [x[\"configuration_type_options\"] for x in config_opts]:\n                tmp.extend(item)\n            config_opts_ids = [x[\"id\"] for x in tmp]\n            for id in lab_config[\"options\"]:\n                assert (\n                    id in config_opts_ids\n                ), \"Invalid configuration option ID.\"\n        elif list(lab_config.keys()) == [\"profile_id\"]:\n            config_profiles = adaboard.request_adaboard(\n                path=\"jupyter/system/configurationprofiles\"\n            ).json()\n            config_profiles_ids = [x[\"id\"] for x in config_profiles]\n            assert (\n                lab_config[\"profile_id\"] in config_profiles_ids\n            ), \"Invalid configuration profile ID.\"\n\n    payload = {\n        \"start_lab\": start_lab,\n        \"lab_configuration\": lab_config,\n    }\n    response = adaboard.request_adaboard(\n        path=f\"cards/{card_id}/launch\", method=requests.post, json=payload\n    ).json()\n\n    card_path = response[\"message\"]\n\n    # Set up the card kernel\n    # Get the main Notebook\n    nb_path = card_path[card_path.find(\"/gallery\") + 1 :]\n    response = adaboard.request_adaboard(\n        path=f\"jupyter/files/notebook/content/fetch?path={nb_path}\"\n    ).json()\n    nb_file_dict = json.loads(\n        base64.b64decode(response[\"content\"]).decode(\"utf-8\")\n    )\n\n    # Check if the kernel is custom\n    kernel_pattern = re.compile(r\"^(kp|kt)(\\d+)$\")\n    kernel_match = kernel_pattern.match(\n        nb_file_dict[\"metadata\"][\"kernelspec\"][\"name\"]\n    )\n    if kernel_match:\n        # Check if the kernel linked to the card is installed. If not, install it\n        id_dict = {}\n        kernels = adaboard.request_adaboard(path=\"jupyter/kernelspecs\").json()\n        if kernel_match.group(1) == \"kp\":\n            kernel_metadata_id = int(kernel_match.group(2))\n            try:\n                [x for x in kernels if x[\"metadata_id\"] == kernel_metadata_id][\n                    0\n                ]\n            except IndexError:\n                id_dict = {\"metadata_id\": kernel_metadata_id}\n        elif kernel_match.group(1) == \"kt\":\n            kernel_run_id = int(kernel_match.group(2))\n            try:\n                [x for x in kernels if x[\"run_id\"] == kernel_run_id][0]\n            except IndexError:\n                id_dict = {\"run_id\": kernel_run_id}\n        # If the kernel is not installed and it exists, install it\n        if id_dict:\n            payload = {\n                \"display_name\": nb_file_dict[\"metadata\"][\"kernelspec\"][\n                    \"display_name\"\n                ],\n                \"include_dummy_notebook\": False,\n                \"start_options\": {\"start_lab\": False, \"lab_configuration\": {}},\n            }\n            payload.update(id_dict)\n            adaboard.request_adaboard(\n                path=\"jupyter/kernelspecs\",\n                method=requests.post,\n                json=payload,\n            )\n\n    return card_path\n</code></pre>"},{"location":"cards/#adalib.cards.register_as_reviewer","title":"register_as_reviewer","text":"<pre><code>register_as_reviewer(card_id)\n</code></pre> <p>Register invoker as card reviewer.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>int</code> <p>the id of the card for which the user will become reviewer</p> required <p>Returns:</p> Type Description <code>None</code> <p>Nothing</p> Source code in <code>adalib/cards/cards.py</code> <pre><code>def register_as_reviewer(card_id: int) -&gt; None | str:\n    \"\"\"\n    Register invoker as card reviewer.\n\n    :param card_id: the id of the card for which the user will become reviewer\n    :type card_id: int\n    :return: Nothing\n    :rtype: None\n    \"\"\"\n\n    adaboard.request_adaboard(\n        path=f\"cards/{card_id}/reviewer\", method=requests.put\n    )\n\n    return None\n</code></pre>"},{"location":"cards/#adalib.cards.set_card_visibility","title":"set_card_visibility","text":"<pre><code>set_card_visibility(card_id, new_status)\n</code></pre> <p>Set the visibility status of a specific card in the Gallery.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>int</code> <p>the id of the card whose visibility is to be set</p> required <code>new_status</code> <code>str</code> <p>visibility to be set</p> required <p>Returns:</p> Type Description <code>None</code> <p>Nothing</p> Source code in <code>adalib/cards/cards.py</code> <pre><code>def set_card_visibility(card_id: int, new_status: str) -&gt; None | str:\n    \"\"\"\n    Set the visibility status of a specific card in the Gallery.\n\n    :param card_id: the id of the card whose visibility is to be set\n    :type card_id: int\n    :param new_status: visibility to be set\n    :type new_status: bool\n    :return: Nothing\n    :rtype: None\n    \"\"\"\n\n    assert new_status.lower() in [\n        \"exposed\",\n        \"hidden\",\n    ], \"Status must be 'exposed' or 'hidden'\"\n\n    status_dict = {\"exposed\": \"false\", \"hidden\": \"true\"}\n    new_status = new_status.lower()\n    payload = {\"hidden\": status_dict[new_status]}\n    adaboard.request_adaboard(\n        path=f\"cards/{card_id}/hidden\", method=requests.put, json=payload\n    )\n\n    return None\n</code></pre>"},{"location":"cards/#adalib.cards.toggle_card_favorite","title":"toggle_card_favorite","text":"<pre><code>toggle_card_favorite(card_id)\n</code></pre> <p>Toggle the favorite status of a card in the Gallery.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>int</code> <p>the id of the card whose status is to be toggled</p> required <p>Returns:</p> Type Description <code>str</code> <p>a message describing new status</p> Source code in <code>adalib/cards/cards.py</code> <pre><code>def toggle_card_favorite(card_id: int) -&gt; str:\n    \"\"\"\n    Toggle the favorite status of a card in the Gallery.\n\n    :param card_id: the id of the card whose status is to be toggled\n    :type card_id: int\n    :return: a message describing new status\n    :rtype: str\n    \"\"\"\n\n    response = adaboard.request_adaboard(\n        path=f\"favorite/{card_id}\", method=requests.post\n    ).json()\n\n    return response[\"message\"]\n</code></pre>"},{"location":"config/","title":"<code>adalib.config</code>","text":"<p>The Config sub-package sets up the environment for adalib. It also fetches all the configuration values needed in the library.</p> <p>The first client call to import this module will initialize it, after which it will be a singleton instantiation for the duration of the process.</p>"},{"location":"config/#adalib.config-classes","title":"Classes","text":""},{"location":"config/#adalib.config.Configuration","title":"Configuration","text":"<p>Configuration singleton class.</p> Source code in <code>adalib/config/config.py</code> <pre><code>class Configuration(metaclass=Singleton):\n    \"\"\"Configuration singleton class.\"\"\"\n\n    def __init__(self, adaboard_api_url=None, **kwargs):\n        self.LOG_LEVEL = os.getenv(\"ADALIB_LOG_LEVEL\", \"INFO\")\n        self.HARBOR_AUTH_FILE = os.path.join(\n            os.getenv(\"XDG_RUNTIME_DIR\", \".docker\"), \"config.json\"\n        )\n        self.__configure_logging()\n        self.__configure_environment()\n        self.__configure_adaboard(adaboard_api_url=adaboard_api_url)\n        self.__configure_clients()\n        self.__configure_services()\n        self.__configure_credentials(**kwargs)\n        match self.ENVIRONMENT:\n            case \"jupyterhub\":\n                logging.info(\"adalib configured, running in JupyterHub.\")\n            case \"nonpub-user-app\":\n                logging.info(\n                    \"adalib configured, running in a non-public deployed app.\"\n                )\n            case \"external\":\n                logging.info(\n                    \"adalib configured, running in an external environment.\"\n                )\n\n    def __configure_credentials(self, **kwargs):\n        \"\"\"access token and refresh token refer to the JH client\"\"\"\n        if self.ENVIRONMENT == \"jupyterhub\":\n            self.CREDENTIALS = {\n                \"username\": os.environ[\"LOGNAME\"],\n                \"jh_token\": os.environ[\"JUPYTERHUB_API_TOKEN\"],\n                \"access_token\": None,\n                \"refresh_token\": None,\n            }\n        elif self.ENVIRONMENT == \"nonpub-user-app\":\n            self.CREDENTIALS = {\n                \"client_id\": os.environ[\"_UA_CLIENT_ID\"],\n                \"client_secret\": os.environ[\"_UA_CLIENT_SECRET\"],\n                \"app_access_token\": kwargs.get(\n                    \"app_access_token\"\n                ),  # Deployed app client\n                \"app_refresh_token\": kwargs.get(\n                    \"app_refresh_token\"\n                ),  # Deployed app client\n                \"access_token\": None,\n                \"refresh_token\": None,\n            }\n        elif self.ENVIRONMENT == \"external\":\n            self.CREDENTIALS = {\n                \"username\": kwargs.get(\"username\"),\n                \"password\": kwargs.get(\"password\"),\n                \"access_token\": kwargs.get(\"access_token\"),\n                \"refresh_token\": kwargs.get(\"refresh_token\"),\n            }\n\n    def __configure_environment(self, **kwargs):\n        \"\"\"\n        Find out in which environment is adalib running.\n        \"\"\"\n        if \"JUPYTERHUB_API_TOKEN\" in os.environ:\n            self.ENVIRONMENT = \"jupyterhub\"\n        elif \"_UA_CLIENT_ID\" in os.environ:\n            self.ENVIRONMENT = \"nonpub-user-app\"\n        else:\n            self.ENVIRONMENT = \"external\"\n\n    def __configure_adaboard(self, adaboard_api_url=None):\n        if self.ENVIRONMENT == \"external\" and (\n            adaboard_api_url is None and \"ADABOARD_API_URL\" not in os.environ\n        ):\n            raise ValueError(\n                \"adaboard_api_url must be provided for external environment\"\n            )\n        if adaboard_api_url:\n            self.ADABOARD_API_URL = adaboard_api_url\n        elif \"ADABOARD_API_URL\" in os.environ:\n            self.ADABOARD_API_URL = os.environ[\"ADABOARD_API_URL\"]\n        elif \"_NAMESPACE\" in os.environ:\n            self.ADABOARD_API_URL = (\n                f\"http://adaboard-api-svc.{os.environ['_NAMESPACE']}:8000\"\n            )\n        else:\n            self.ADABOARD_API_URL = \"http://adaboard-api-svc:8000\"\n\n    def __configure_service_x(self, x: str, given_name: str, apps: list[dict]):\n        url_type = \"external\" if self.ENVIRONMENT == \"external\" else \"internal\"\n        for app in apps:\n            if app[\"name\"] == x:\n                url_parsed = urllib.parse.urlparse(url=app[url_type])\n                self.SERVICES[given_name] = {\n                    \"url\": app[\"internal\"],\n                    \"external\": app[\"external\"],\n                    \"netloc\": url_parsed.netloc,\n                    \"path\": url_parsed.path,\n                }\n\n    def __configure_services(self):\n        resp = requests.get(\n            self.ADABOARD_API_URL,\n            params={\"include_apps\": True},\n            timeout=10,\n        ).json()\n\n        apps = resp[\"apps\"]\n\n        if (\n            resp[\"jh_secret\"] == \"\"\n            and \"ADALAB_CLIENT_SECRET\" not in os.environ\n        ):\n            raise ValueError(\"AdaLab client secret was not set\")\n        elif resp[\"jh_secret\"] == \"\":\n            self.KEYCLOAK_CLIENTS[\"jupyterhub_secret\"] = os.environ[\n                \"ADALAB_CLIENT_SECRET\"\n            ]\n        else:\n            self.KEYCLOAK_CLIENTS[\"jupyterhub_secret\"] = resp[\"jh_secret\"]\n\n        namespace = resp[\"namespace\"]\n        network_host = resp[\"network_host\"]\n\n        self.NAMESPACE = namespace\n        self.NETWORK_HOST = network_host\n        self.SERVICES = dict()\n        self.__configure_service_x(\n            x=\"adaboard-api\", given_name=\"adaboard-api\", apps=apps\n        )\n        self.__configure_service_x(\n            x=\"container-registry\", given_name=\"harbor\", apps=apps\n        )\n        self.__configure_service_x(\n            x=\"jupyterhub\", given_name=\"jupyterhub\", apps=apps\n        )\n        self.__configure_service_x(\n            x=\"keycloak\", given_name=\"keycloak\", apps=apps\n        )\n        self.__configure_service_x(x=\"mlflow\", given_name=\"mlflow\", apps=apps)\n        self.__configure_service_x(\n            x=\"superset\", given_name=\"superset\", apps=apps\n        )\n\n    def __configure_clients(self):\n        self.KEYCLOAK_REALM = os.environ.get(\"KEYCLOAK_REALM\", \"adalab\")\n        self.KEYCLOAK_CLIENTS = dict()\n        self.KEYCLOAK_CLIENTS[\"adaboard-api\"] = os.environ.get(\n            \"KEYCLOAK_ADABOARD_CLIENT_ID\", \"adaboard\"\n        )\n        self.KEYCLOAK_CLIENTS[\"harbor\"] = os.environ.get(\n            \"KEYCLOAK_HARBOR_CLIENT_ID\", \"harbor\"\n        )\n        self.KEYCLOAK_CLIENTS[\"jupyterhub\"] = os.environ.get(\n            \"KEYCLOAK_JUPYTERHUB_CLIENT_ID\", \"jupyterhub\"\n        )\n        self.KEYCLOAK_CLIENTS[\"superset\"] = os.environ.get(\n            \"KEYCLOAK_SUPERSET_CLIENT_ID\", \"superset\"\n        )\n\n    def __configure_logging(self):\n        log_level = getattr(logging, self.LOG_LEVEL.upper(), logging.INFO)\n        logging.basicConfig(\n            level=log_level,\n            format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n        )\n\n    @classmethod\n    def clean(cls):\n        \"\"\"\n        Delete existing instances of the class.\n        \"\"\"\n        cls.reset_instances()\n\n    def reset(self, adaboard_api_url=None, **kwargs):\n        \"\"\"\n        Clean up and create a new class instance with the new parameters.\n        \"\"\"\n        self.clean()\n        self.__init__(adaboard_api_url=adaboard_api_url, **kwargs)\n</code></pre>"},{"location":"config/#adalib.config.Configuration-functions","title":"Functions","text":""},{"location":"config/#adalib.config.Configuration.__configure_credentials","title":"__configure_credentials","text":"<pre><code>__configure_credentials(**kwargs)\n</code></pre> <p>access token and refresh token refer to the JH client</p> Source code in <code>adalib/config/config.py</code> <pre><code>def __configure_credentials(self, **kwargs):\n    \"\"\"access token and refresh token refer to the JH client\"\"\"\n    if self.ENVIRONMENT == \"jupyterhub\":\n        self.CREDENTIALS = {\n            \"username\": os.environ[\"LOGNAME\"],\n            \"jh_token\": os.environ[\"JUPYTERHUB_API_TOKEN\"],\n            \"access_token\": None,\n            \"refresh_token\": None,\n        }\n    elif self.ENVIRONMENT == \"nonpub-user-app\":\n        self.CREDENTIALS = {\n            \"client_id\": os.environ[\"_UA_CLIENT_ID\"],\n            \"client_secret\": os.environ[\"_UA_CLIENT_SECRET\"],\n            \"app_access_token\": kwargs.get(\n                \"app_access_token\"\n            ),  # Deployed app client\n            \"app_refresh_token\": kwargs.get(\n                \"app_refresh_token\"\n            ),  # Deployed app client\n            \"access_token\": None,\n            \"refresh_token\": None,\n        }\n    elif self.ENVIRONMENT == \"external\":\n        self.CREDENTIALS = {\n            \"username\": kwargs.get(\"username\"),\n            \"password\": kwargs.get(\"password\"),\n            \"access_token\": kwargs.get(\"access_token\"),\n            \"refresh_token\": kwargs.get(\"refresh_token\"),\n        }\n</code></pre>"},{"location":"config/#adalib.config.Configuration.__configure_environment","title":"__configure_environment","text":"<pre><code>__configure_environment(**kwargs)\n</code></pre> <p>Find out in which environment is adalib running.</p> Source code in <code>adalib/config/config.py</code> <pre><code>def __configure_environment(self, **kwargs):\n    \"\"\"\n    Find out in which environment is adalib running.\n    \"\"\"\n    if \"JUPYTERHUB_API_TOKEN\" in os.environ:\n        self.ENVIRONMENT = \"jupyterhub\"\n    elif \"_UA_CLIENT_ID\" in os.environ:\n        self.ENVIRONMENT = \"nonpub-user-app\"\n    else:\n        self.ENVIRONMENT = \"external\"\n</code></pre>"},{"location":"config/#adalib.config.Configuration.clean","title":"clean  <code>classmethod</code>","text":"<pre><code>clean()\n</code></pre> <p>Delete existing instances of the class.</p> Source code in <code>adalib/config/config.py</code> <pre><code>@classmethod\ndef clean(cls):\n    \"\"\"\n    Delete existing instances of the class.\n    \"\"\"\n    cls.reset_instances()\n</code></pre>"},{"location":"config/#adalib.config.Configuration.reset","title":"reset","text":"<pre><code>reset(adaboard_api_url=None, **kwargs)\n</code></pre> <p>Clean up and create a new class instance with the new parameters.</p> Source code in <code>adalib/config/config.py</code> <pre><code>def reset(self, adaboard_api_url=None, **kwargs):\n    \"\"\"\n    Clean up and create a new class instance with the new parameters.\n    \"\"\"\n    self.clean()\n    self.__init__(adaboard_api_url=adaboard_api_url, **kwargs)\n</code></pre>"},{"location":"config/#adalib.config-functions","title":"Functions","text":""},{"location":"config/#adalib.config.get_config","title":"get_config","text":"<pre><code>get_config(adaboard_api_url=None, **kwargs)\n</code></pre> <p>Initialize the Configuration singleton. This is called automatically when the Configuration class is imported.</p> Source code in <code>adalib/config/config.py</code> <pre><code>def get_config(adaboard_api_url=None, **kwargs):\n    \"\"\"\n    Initialize the Configuration singleton. This is called automatically when\n    the Configuration class is imported.\n    \"\"\"\n    if \"_IN_ADALIB_TEST_FRAMEWORK\" in os.environ:\n        Config = MagicMock()\n        Config.SERVICES = {\n            \"jupyterhub\": {\"url\": \"http://hub:8081/jupyterhub\"},\n            \"superset\": {\n                \"external\": \"https://superset.adalab.test\",\n                \"url\": \"http://0.1.2.3:8088\",\n            },\n            \"keycloak\": {\n                \"url\": \"http://0.1.3.4:80/gallery/keycloak\",\n                \"external\": \"https://0.1.3.4:80/gallery/keycloak\",\n            },\n            \"adaboard-api\": {\n                \"netloc\": \"0.1.4.5:8000\",\n                \"external\": \"0.1.4.5:8000\",\n            },\n            \"container-registry\": {\n                \"url\": \"http://harbor.internal\",\n                \"netloc\": \"harbor.internal\",\n            },\n            \"mlflow\": {\"external\": \"https://adalab.test/mlflow\"},\n        }\n        Config.KEYCLOAK_REALM = os.environ[\"KEYCLOAK_REALM\"]\n        Config.NAMESPACE = \"test\"\n        Config.NETWORK_HOST = \"adalab.test\"\n        Config.ENVIRONMENT = \"jupyterhub\"\n        Config.CREDENTIALS = {\n            \"username\": \"john\",\n            \"jh_token\": \"test\",\n            \"access_token\": None,\n            \"refresh_token\": None,\n        }\n        Config.KEYCLOAK_CLIENTS[\"adaboard-api\"] = \"jupyterhub\"\n        return Config\n    else:\n        return Configuration(adaboard_api_url=adaboard_api_url, **kwargs)\n</code></pre>"},{"location":"harbor/","title":"<code>adalib.harbor</code>","text":"<p>The Harbor sub-package exposes the core integrations of the Harbor container image registry connected to AdaLab.</p>"},{"location":"harbor/#adalib.harbor-functions","title":"Functions","text":""},{"location":"harbor/#adalib.harbor.archive_image","title":"archive_image","text":"<pre><code>archive_image(metadata_id)\n</code></pre> <p>Archive an image in the Harbor registry. This will archive the OCI image metadata object and works as a soft delete.</p> <p>Parameters:</p> Name Type Description Default <code>metadata_id</code> <code>int</code> <p>the metadata ID of the image</p> required <p>Returns:</p> Type Description <code>None</code> <p>nothing</p> Source code in <code>adalib/harbor/harbor.py</code> <pre><code>def archive_image(metadata_id: int) -&gt; None:\n    \"\"\"Archive an image in the Harbor registry. This will archive the OCI image metadata object and works as a soft delete.\n\n    :param metadata_id: the metadata ID of the image\n    :type metadata_id: int\n    :return: nothing\n    :rtype: None\n    \"\"\"\n\n    # Check if image is already archived\n    img_metadata = adaboard.request_adaboard(\n        path=f\"registry/metadata/{metadata_id}\",\n    ).json()\n    # If not archived, archive it\n    if not img_metadata[\"archived\"]:\n        payload = {\"archived\": True}\n        adaboard.request_adaboard(\n            path=f\"registry/metadata/{metadata_id}/archive\",\n            method=requests.put,\n            json=payload,\n        )\n        return None\n    else:\n        raise RuntimeError(\n            f\"Image with metadata ID {metadata_id} is already archived.\"\n        )\n</code></pre>"},{"location":"harbor/#adalib.harbor.create_image_metadata","title":"create_image_metadata","text":"<pre><code>create_image_metadata(source_type, source_repository, source_tag, project_name, repository_name, tag, type_id, name, description, username, cmd='')\n</code></pre> <p>Create metadata for a specific image in the Harbor registry.</p> <p>Parameters:</p> Name Type Description Default <code>source_type</code> <code>str</code> <p>the location where the source image is to be pulled from</p> required <code>source_repository</code> <code>str</code> <p>the name of the repository of the source image</p> required <code>source_tag</code> <code>str</code> <p>the tag of the source image</p> required <code>project_name</code> <code>str</code> <p>the name of the target project for the image metadata</p> required <code>repository_name</code> <code>str</code> <p>the name of the target repository for the image metadata</p> required <code>tag</code> <code>str</code> <p>the tag for the target image metadata</p> required <code>type_id</code> <code>str</code> <p>the type of the image</p> required <code>name</code> <code>str</code> <p>the name for the target image metadata</p> required <code>description</code> <code>str</code> <p>the description for the target image metadata</p> required <code>username</code> <code>str</code> <p>the current username (tip: check \"LOGNAME\" environment variable)</p> required <code>cmd</code> <code>str</code> <p>the startup command for the target image metadata, defaults to \"\"</p> <code>''</code> <p>Returns:</p> Type Description <code>dict</code> <p>image metadata</p> Source code in <code>adalib/harbor/harbor.py</code> <pre><code>def create_image_metadata(\n    source_type: str,\n    source_repository: str,\n    source_tag: str,\n    project_name: str,\n    repository_name: str,\n    tag: str,\n    type_id: str,\n    name: str,\n    description: str,\n    username: str,\n    cmd: str = \"\",\n) -&gt; dict[str, str | int | bool | dict[str, str]]:\n    \"\"\"Create metadata for a specific image in the Harbor registry.\n\n    :param source_type: the location where the source image is to be pulled from\n    :type source_type: str\n    :param source_repository: the name of the repository of the source image\n    :type source_repository: str\n    :param source_tag: the tag of the source image\n    :type source_tag: str\n    :param project_name: the name of the target project for the image metadata\n    :type project_name: str\n    :param repository_name: the name of the target repository for the image metadata\n    :type: repository_name: str\n    :param tag: the tag for the target image metadata\n    :type tag: str\n    :param type_id: the type of the image\n    :type type_id: str\n    :param name: the name for the target image metadata\n    :type name: str\n    :param description: the description for the target image metadata\n    :type description: str\n    :param username: the current username (tip: check \"LOGNAME\" environment variable)\n    :type username: str\n    :param cmd: the startup command for the target image metadata, defaults to \"\"\n    :type cmd: str, optional\n    :return: image metadata\n    :rtype: dict\n    \"\"\"\n    # TODO fix the use of environmental variables here\n    adalib_config = config.get_config()\n\n    # Make sure container options are valid\n    assert (\n        project_name in ALLOWED_OCI_PROJECT_TYPES\n    ), f\"Can only create metadata for images that are of the type {', '.join([x for x in ALLOWED_OCI_PROJECT_TYPES])}\"\n    assert (\n        type_id in ALLOWED_METADATA_TYPES\n    ), f\"Can only create metadata of the type {', '.join([x for x in ALLOWED_METADATA_TYPES])}\"\n    assert (\n        source_type in ALLOWED_OCI_SOURCE_TYPES\n    ), f\"Can only create metadata for images located in {', '.join([x for x in ALLOWED_OCI_SOURCE_TYPES])}\"\n\n    # Create metadata object in AdaLab\n    payload = {\n        \"sha256\": \"sha256:00000\",\n        \"oci_image_name\": {\n            \"project\": project_name,\n            \"repository\": repository_name,\n            \"tag\": tag,\n            \"host\": f\"{HARBOR_HOST}:{HARBOR_PORT}\",\n        },\n        \"type\": type_id,\n        \"name\": name,\n        \"description\": description,\n        \"startup_cmd\": cmd,\n    }\n\n    response_metadata = adaboard.request_adaboard(\n        path=\"registry/metadata\", method=requests.post, json=payload\n    ).json()\n\n    # Build request payload based on user and default options\n    source_project = \"kernels_temp\"\n\n    if source_type.lower() == \"lab\":\n        source_image = f\"localhost/{source_repository}:{source_tag}\"\n    elif source_type.lower() == \"registry\":\n        source_image = f\"{adalib_config.SERVICES['container-registry']['netloc']}/{source_project}/{source_repository}:{source_tag}\"\n\n    payload = {\n        \"script\": \"pusher\",\n        \"user_id\": username,\n        \"pool\": \"internal\",\n        \"cleanup\": True,\n        \"timeout\": 3600,\n        \"run_in_isolation\": False,\n        \"start_podman_sidecar\": False,\n        \"config\": {\n            \"ADABOARD_API_URL\": {\n                \"value\": adalib_config.SERVICES[\"adaboard-api\"][\"external\"],\n                \"real_value\": adalib_config.SERVICES[\"adaboard-api\"][\n                    \"external\"\n                ],\n            },\n            \"CONTAINER_METADATA_ID\": {\n                \"value\": response_metadata[\"metadata_id\"],\n                \"real_value\": response_metadata[\"metadata_id\"],\n            },\n            \"HARBOR_HOST\": {\n                \"value\": HARBOR_HOST,\n                \"real_value\": HARBOR_HOST,\n            },\n            \"HARBOR_NAMESPACE\": {\n                \"value\": adalib_config.NAMESPACE,\n                \"real_value\": adalib_config.NAMESPACE,\n            },\n            \"HARBOR_TARGET_PROJECT\": {\n                \"value\": response_metadata[\"oci_image_name\"][\"project\"],\n                \"real_value\": response_metadata[\"oci_image_name\"][\"project\"],\n            },\n            \"HARBOR_TARGET_REPOSITORY_NAME\": {\n                \"value\": response_metadata[\"oci_image_name\"][\"repository\"],\n                \"real_value\": response_metadata[\"oci_image_name\"][\n                    \"repository\"\n                ],\n            },\n            \"HARBOR_TARGET_TAG\": {\n                \"value\": response_metadata[\"oci_image_name\"][\"tag\"],\n                \"real_value\": response_metadata[\"oci_image_name\"][\"tag\"],\n            },\n            \"KEEP_IMAGES\": {\"value\": True, \"real_value\": True},\n            \"NETWORK_HOST\": {\n                \"value\": adalib_config.NETWORK_HOST,\n                \"real_value\": adalib_config.NETWORK_HOST,\n            },\n            \"OPERATION\": {\"value\": \"push\", \"real_value\": \"push\"},\n            \"RAW_SOURCE_IMAGE\": {\n                \"value\": f\"{source_image}\",\n                \"real_value\": f\"{source_image}\",\n            },\n        },\n    }\n\n    # Push image from a source to a target repo in Harbor\n    response_pusher = adaboard.request_adaboard(\n        path=\"script_runner/runs/start/\", method=requests.post, json=payload\n    ).json()\n\n    # Update metadata object in AdaLab\n    payload = {\n        \"name\": response_metadata[\"name\"],\n        \"description\": response_metadata[\"description\"],\n        \"startup_cmd\": response_metadata[\"startup_cmd\"],\n        \"run_id\": response_pusher[\"id\"],\n    }\n\n    adaboard.request_adaboard(\n        path=f\"registry/metadata/{response_metadata['metadata_id']}\",\n        method=requests.put,\n        json=payload,\n    )\n\n    # Update image state in AdaLab to the one in Harbor\n    adaboard.request_adaboard(\n        path=f\"registry/metadata/{response_metadata['metadata_id']}/ready\",\n        method=requests.put,\n    ).json()\n\n    # Get image metadata from AdaLab\n    response = adaboard.request_adaboard(\n        path=f\"registry/metadata/{response_metadata['metadata_id']}\",\n    ).json()\n\n    return response\n</code></pre>"},{"location":"harbor/#adalib.harbor.edit_image_metadata","title":"edit_image_metadata","text":"<pre><code>edit_image_metadata(metadata_id, new_name='', new_description='', new_cmd='', new_run_id=0)\n</code></pre> <p>Edit the metadata of an image in the Harbor registry.</p> <p>Parameters:</p> Name Type Description Default <code>metadata_id</code> <code>int</code> <p>the metadata ID of the image</p> required <code>new_name</code> <code>str</code> <p>the new name of the image, defaults to \"\"</p> <code>''</code> <code>new_description</code> <code>str</code> <p>the new description of the image, defaults to \"\"</p> <code>''</code> <code>new_cmd</code> <code>str</code> <p>the new startup command of the image, defaults to \"\"</p> <code>''</code> <code>new_run_id</code> <code>int</code> <p>the new run ID of the image, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>None</code> <p>nothing</p> Source code in <code>adalib/harbor/harbor.py</code> <pre><code>def edit_image_metadata(\n    metadata_id: int,\n    new_name: str = \"\",\n    new_description: str = \"\",\n    new_cmd: str = \"\",\n    new_run_id: int = 0,\n) -&gt; None:\n    \"\"\"Edit the metadata of an image in the Harbor registry.\n\n    :param metadata_id: the metadata ID of the image\n    :type metadata_id: int\n    :param new_name: the new name of the image, defaults to \"\"\n    :type image_name: str, optional\n    :param new_description: the new description of the image, defaults to \"\"\n    :type new_description: str, optional\n    :param new_cmd: the new startup command of the image, defaults to \"\"\n    :type new_cmd: str, optional\n    :param new_run_id: the new run ID of the image, defaults to 0\n    :type new_run_id: int, optional\n    :return: nothing\n    :rtype: None\n    \"\"\"\n\n    # Build request payload based on new and old options\n    old_metadata = adaboard.request_adaboard(\n        path=f\"registry/metadata/{metadata_id}\",\n    ).json()\n\n    if not new_name:\n        new_name = old_metadata[\"name\"]\n    if not new_description:\n        new_description = old_metadata[\"description\"]\n    if not new_cmd:\n        new_cmd = old_metadata[\"startup_cmd\"]\n    if not new_run_id:\n        new_run_id = old_metadata[\"run_id\"]\n\n    payload = {\n        \"name\": new_name,\n        \"description\": new_description,\n        \"startup_cmd\": new_cmd,\n        \"run_id\": new_run_id,\n    }\n\n    # Edit metadata\n    adaboard.request_adaboard(\n        path=f\"registry/metadata/{metadata_id}\",\n        method=requests.put,\n        json=payload,\n    )\n\n    return None\n</code></pre>"},{"location":"harbor/#adalib.harbor.get_all_metadata","title":"get_all_metadata","text":"<pre><code>get_all_metadata(include_archived=False)\n</code></pre> <p>Get metadata for all images in the Harbor registry.</p> <p>Parameters:</p> Name Type Description Default <code>include_archived</code> <code>bool</code> <p>whether to include archived images, defaults to False</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>metadata for all images</p> Source code in <code>adalib/harbor/harbor.py</code> <pre><code>def get_all_metadata(\n    include_archived: bool = False,\n) -&gt; list[dict[str, str | int | bool | dict[str, str]]]:\n    \"\"\"Get metadata for all images in the Harbor registry.\n\n    :param include_archived: whether to include archived images, defaults to False\n    :type include_archived: bool, optional\n    :return: metadata for all images\n    :rtype: list\n    \"\"\"\n    response = adaboard.request_adaboard(\n        path=f\"registry/metadata?get_archived={include_archived}\",\n    ).json()\n\n    return response\n</code></pre>"},{"location":"harbor/#adalib.harbor.get_authenticated_docker_cli","title":"get_authenticated_docker_cli","text":"<pre><code>get_authenticated_docker_cli()\n</code></pre> <p>Get a python docker client that is authenticated with harbor.</p> <p>Returns:</p> Type Description <code>docker.DockerClient</code> <p>configured docker client</p> Source code in <code>adalib/harbor/harbor.py</code> <pre><code>def get_authenticated_docker_cli():\n    \"\"\"Get a python docker client that is authenticated with harbor.\n\n    :return: configured docker client\n    :rtype: docker.DockerClient\n    \"\"\"\n    # Authenticate to docker client\n    adalib_config = config.get_config()\n    dclient = docker.from_env()\n    dclient.api.reload_config(dockercfg_path=adalib_config.HARBOR_AUTH_FILE)\n\n    return dclient\n</code></pre>"},{"location":"harbor/#adalib.harbor.get_image_digest","title":"get_image_digest","text":"<pre><code>get_image_digest(metadata_id)\n</code></pre> <p>Get the digest of an image in the Harbor registry.</p> <p>Parameters:</p> Name Type Description Default <code>metadata_id</code> <code>str</code> <p>the metadata ID of the image</p> required <p>Returns:</p> Type Description <code>str</code> <p>image digest for the remote image</p> Source code in <code>adalib/harbor/harbor.py</code> <pre><code>def get_image_digest(metadata_id: str) -&gt; str:\n    \"\"\"Get the digest of an image in the Harbor registry.\n\n    :param metadata_id: the metadata ID of the image\n    :type metadata_id: int\n    :return: image digest for the remote image\n    :rtype: str\n    \"\"\"\n\n    response = adaboard.request_adaboard(\n        path=f\"registry/metadata/{metadata_id}\",\n    ).json()\n\n    return response[\"sha256\"]\n</code></pre>"},{"location":"harbor/#adalib.harbor.get_image_id","title":"get_image_id","text":"<pre><code>get_image_id(project_name, repository_name, tag)\n</code></pre> <p>Get the ID of an image in the Harbor registry.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>the name of the project the image belongs to</p> required <code>repository_name</code> <code>str</code> <p>the name of the image repository</p> required <code>tag</code> <code>str</code> <p>the tag of the specific image</p> required <p>Returns:</p> Type Description <code>int</code> <p>image metadata ID</p> Source code in <code>adalib/harbor/harbor.py</code> <pre><code>def get_image_id(project_name: str, repository_name: str, tag: str) -&gt; int:\n    \"\"\"Get the ID of an image in the Harbor registry.\n\n    :param project_name: the name of the project the image belongs to\n    :type project_name: str\n    :param repository_name: the name of the image repository\n    :type: repository_name: str\n    :param tag: the tag of the specific image\n    :type tag: str\n    :return: image metadata ID\n    :rtype: int\n    \"\"\"\n    # Make sure image options are valid\n    assert (\n        project_name in ALLOWED_OCI_PROJECT_TYPES\n    ), f\"Can only list IDs for images that are of the type {', '.join([x for x in ALLOWED_OCI_PROJECT_TYPES])}\"\n\n    # Get all images from the repository, page by page\n    all_responses = []\n    page = 1\n    while True:\n        response = adaboard.request_adaboard(\n            path=f\"registry/{project_name}/{repository_name}/images/?page={page}&amp;page_size=10\",\n        ).json()\n        all_responses.extend(response[\"content\"])\n        if not response[\"has_next_page\"]:\n            break\n        page += 1\n\n    # Find the specific image and return its ID\n    for image in all_responses:\n        if image[\"tags\"][0] == tag:\n            return image[\"id\"]\n\n    raise ValueError(\n        f\"Could not find image with tag {tag} in repository {repository_name}\"\n    )\n</code></pre>"},{"location":"harbor/#adalib.harbor.get_image_metadata","title":"get_image_metadata","text":"<pre><code>get_image_metadata(metadata_id)\n</code></pre> <p>Get metadata for a specific image in the Harbor registry based on its ID.</p> <p>Parameters:</p> Name Type Description Default <code>metadata_id</code> <code>int</code> <p>the metadata ID of the image</p> required <p>Returns:</p> Type Description <code>dict</code> <p>image metadata</p> Source code in <code>adalib/harbor/harbor.py</code> <pre><code>def get_image_metadata(\n    metadata_id: int,\n) -&gt; dict[str, str | int | bool | dict[str, str]]:\n    \"\"\"Get metadata for a specific image in the Harbor registry based on its ID.\n\n    :param metadata_id: the metadata ID of the image\n    :type metadata_id: int\n    :return: image metadata\n    :rtype: dict\n    \"\"\"\n\n    response = adaboard.request_adaboard(\n        path=f\"registry/metadata/{metadata_id}\",\n    ).json()\n\n    return response\n</code></pre>"},{"location":"harbor/#adalib.harbor.get_image_metadata_id","title":"get_image_metadata_id","text":"<pre><code>get_image_metadata_id(project_name, repository_name, tag)\n</code></pre> <p>Get the metadata ID for a specific image in the Harbor registry.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>the name of the project the image belongs to</p> required <code>repository_name</code> <code>str</code> <p>the name of the image repository</p> required <code>tag</code> <code>str</code> <p>the tag of the specific image</p> required <p>Returns:</p> Type Description <code>int</code> <p>image metadata ID</p> Source code in <code>adalib/harbor/harbor.py</code> <pre><code>def get_image_metadata_id(\n    project_name: str, repository_name: str, tag: str\n) -&gt; int:\n    \"\"\"Get the metadata ID for a specific image in the Harbor registry.\n\n    :param project_name: the name of the project the image belongs to\n    :type project_name: str\n    :param repository_name: the name of the image repository\n    :type: repository_name: str\n    :param tag: the tag of the specific image\n    :type tag: str\n    :return: image metadata ID\n    :rtype: int\n    \"\"\"\n\n    # Make sure image options are valid\n    assert (\n        project_name in ALLOWED_OCI_PROJECT_TYPES\n    ), f\"Can only list metadata IDs for images that are of the type {', '.join([x for x in ALLOWED_OCI_PROJECT_TYPES])}\"\n\n    # Get metadata for all images\n    response = adaboard.request_adaboard(\n        path=\"registry/metadata?get_archived=true\",\n    ).json()\n\n    # Find the specific image and return its metadata\n    for image in response:\n        if (\n            image[\"oci_image_name\"][\"project\"] == project_name\n            and image[\"oci_image_name\"][\"repository\"] == repository_name\n            and image[\"oci_image_name\"][\"tag\"] == tag\n        ):\n            return image[\"metadata_id\"]\n\n    raise ValueError(\n        f\"Could not find image with tag {tag} in repository {repository_name}\"\n    )\n</code></pre>"},{"location":"harbor/#adalib.harbor.get_project_repositories","title":"get_project_repositories","text":"<pre><code>get_project_repositories(project_name)\n</code></pre> <p>Get all image repositories under a given project name.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>the name of the project to list images from</p> required <p>Returns:</p> Type Description <code>list</code> <p>list of existing images under a given project name</p> Source code in <code>adalib/harbor/harbor.py</code> <pre><code>def get_project_repositories(project_name: str) -&gt; list[str]:\n    \"\"\"Get all image repositories under a given project name.\n\n    :param project_name: the name of the project to list images from\n    :type project_name: str\n    :return: list of existing images under a given project name\n    :rtype: list\n    \"\"\"\n\n    # Make sure project options are valid\n    assert (\n        project_name in ALLOWED_OCI_PROJECT_TYPES\n    ), f\"Can only list images that are of the type {', '.join([x for x in ALLOWED_OCI_PROJECT_TYPES])}\"\n\n    # Get all repositories from the project, page by page\n    all_responses = []\n    page = 1\n    while True:\n        response = adaboard.request_adaboard(\n            path=f\"registry/{project_name}/repositories/?page={page}&amp;page_size=10\",\n        ).json()\n        all_responses.extend(response[\"content\"])\n        if not response[\"has_next_page\"]:\n            break\n        page += 1\n\n    return [x[\"name\"] for x in all_responses]\n</code></pre>"},{"location":"harbor/#adalib.harbor.get_project_stats","title":"get_project_stats","text":"<pre><code>get_project_stats(project_name)\n</code></pre> <p>Get statistics for a specific project in the Harbor registry.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>the name of the project to list repositories from</p> required <p>Returns:</p> Type Description <code>list</code> <p>usage statistics for a given project</p> Source code in <code>adalib/harbor/harbor.py</code> <pre><code>def get_project_stats(project_name: str) -&gt; list[dict[str, str | int]]:\n    \"\"\"Get statistics for a specific project in the Harbor registry.\n\n    :param project_name: the name of the project to list repositories from\n    :type project_name: str\n    :return: usage statistics for a given project\n    :rtype: list\n    \"\"\"\n\n    # Make sure project options are valid\n    assert (\n        project_name in ALLOWED_OCI_PROJECT_TYPES\n    ), f\"Can only show stats of projects that are {', '.join([x for x in ALLOWED_OCI_PROJECT_TYPES])}\"\n\n    # Get all repositories from the project, page by page\n    all_responses = []\n    page = 1\n    while True:\n        response = adaboard.request_adaboard(\n            path=f\"registry/{project_name}/repositories/?page={page}&amp;page_size=10\",\n        ).json()\n        all_responses.extend(response[\"content\"])\n        if not response[\"has_next_page\"]:\n            break\n        page += 1\n\n    # Compile and return statistics\n    return [\n        {\"repository\": x[\"name\"], \"count\": x[\"image_amount\"]}\n        for x in all_responses\n    ]\n</code></pre>"},{"location":"harbor/#adalib.harbor.get_projects","title":"get_projects","text":"<pre><code>get_projects(include_archived=False)\n</code></pre> <p>Get a list of the projects in the Harbor registry.</p> <p>Parameters:</p> Name Type Description Default <code>include_archived</code> <code>bool</code> <p>whether to include archived projects</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>list of existing projects</p> Source code in <code>adalib/harbor/harbor.py</code> <pre><code>def get_projects(include_archived: bool = False) -&gt; list[str]:\n    \"\"\"Get a list of the projects in the Harbor registry.\n\n    :param include_archived: whether to include archived projects\n    :type include_archived: bool\n    :return: list of existing projects\n    :rtype: list\n    \"\"\"\n\n    response = adaboard.request_adaboard(\n        path=f\"registry/metadata?get_archived={include_archived}\",\n    ).json()\n\n    projects = [x[\"oci_image_name\"][\"project\"] for x in response]\n\n    return list(set(projects))\n</code></pre>"},{"location":"harbor/#adalib.harbor.get_repositories_by_author","title":"get_repositories_by_author","text":"<pre><code>get_repositories_by_author(author_id, include_archived=False)\n</code></pre> <p>Get a list of the repositories in the Harbor registry by author ID.</p> <p>Parameters:</p> Name Type Description Default <code>author_id</code> <code>str</code> <p>the ID of the author to list repositories from</p> required <code>include_archived</code> <code>bool</code> <p>whether to include archived images, defaults to False</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>list of existing repositories from a given author</p> Source code in <code>adalib/harbor/harbor.py</code> <pre><code>def get_repositories_by_author(\n    author_id: str,\n    include_archived: bool = False,\n) -&gt; list[str]:\n    \"\"\"Get a list of the repositories in the Harbor registry by author ID.\n\n    :param author_id: the ID of the author to list repositories from\n    :type author_id: str\n    :param include_archived: whether to include archived images, defaults to False\n    :type include_archived: bool, optional\n    :return: list of existing repositories from a given author\n    :rtype: list\n    \"\"\"\n\n    response = adaboard.request_adaboard(\n        path=f\"registry/metadata?get_archived={include_archived}\",\n    ).json()\n\n    author_repos = [x[\"name\"] for x in response if x[\"user_id\"] == author_id]\n\n    return list(set(author_repos))\n</code></pre>"},{"location":"harbor/#adalib.harbor.get_repositories_by_type","title":"get_repositories_by_type","text":"<pre><code>get_repositories_by_type(type_id, include_archived=False)\n</code></pre> <p>Get a list of the repositories in the Harbor registry by image type.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <p>type of image</p> required <code>include_archived</code> <code>bool</code> <p>whether to include archived images, defaults to False</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>list of existing repositories of a given type</p> Source code in <code>adalib/harbor/harbor.py</code> <pre><code>def get_repositories_by_type(\n    type_id: str, include_archived: bool = False\n) -&gt; list[str]:\n    \"\"\"Get a list of the repositories in the Harbor registry by image type.\n\n    :param type: type of image\n    :type type: str\n    :param include_archived: whether to include archived images, defaults to False\n    :type include_archived: bool, optional\n    :return: list of existing repositories of a given type\n    :rtype: list\n    \"\"\"\n\n    # Make sure image options are valid\n    assert (\n        type_id in ALLOWED_METADATA_TYPES\n    ), f\"Can only get repositories of the type {', '.join([x for x in ALLOWED_METADATA_TYPES])}\"\n\n    response = adaboard.request_adaboard(\n        path=f\"registry/metadata?get_archived={include_archived}\",\n    ).json()\n\n    type_repos = [x[\"name\"] for x in response if x[\"type\"] == type_id]\n\n    return list(set(type_repos))\n</code></pre>"},{"location":"harbor/#adalib.harbor.get_repository_tags","title":"get_repository_tags","text":"<pre><code>get_repository_tags(project_name, repository_name)\n</code></pre> <p>Get all tags of an image in the Harbor registry.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>the name of the project the image belongs to</p> required <code>repository_name</code> <code>str</code> <p>the name of the image repository</p> required <p>Returns:</p> Type Description <code>list</code> <p>list of existing image tags</p> Source code in <code>adalib/harbor/harbor.py</code> <pre><code>def get_repository_tags(project_name: str, repository_name: str) -&gt; list[str]:\n    \"\"\"Get all tags of an image in the Harbor registry.\n\n    :param project_name: the name of the project the image belongs to\n    :type project_name: str\n    :param repository_name: the name of the image repository\n    :type: repository_name: str\n    :return: list of existing image tags\n    :rtype: list\n    \"\"\"\n\n    # Make sure repository options are valid\n    assert (\n        project_name in ALLOWED_OCI_PROJECT_TYPES\n    ), f\"Can only list tags for images that are of the type {', '.join([x for x in ALLOWED_OCI_PROJECT_TYPES])}\"\n\n    # Get all images from the repository, page by page\n    all_responses = []\n    page = 1\n    while True:\n        response = adaboard.request_adaboard(\n            path=f\"registry/{project_name}/{repository_name}/images/?page={page}&amp;page_size=10\",\n        ).json()\n        all_responses.extend(response[\"content\"])\n        if not response[\"has_next_page\"]:\n            break\n        page += 1\n\n    return [response[\"tags\"][0] for response in all_responses]\n</code></pre>"},{"location":"harbor/#adalib.harbor.get_types","title":"get_types","text":"<pre><code>get_types()\n</code></pre> <p>Get a list of the image types in the Harbor registry.</p> <p>Returns:</p> Type Description <code>list</code> <p>list of existing types</p> Source code in <code>adalib/harbor/harbor.py</code> <pre><code>def get_types() -&gt; list[str]:\n    \"\"\"Get a list of the image types in the Harbor registry.\n\n    :return: list of existing types\n    :rtype: list\n    \"\"\"\n\n    response = adaboard.request_adaboard(\n        path=\"registry/metadata\",\n    ).json()\n\n    types = [x[\"type\"] for x in response]\n\n    return list(set(types))\n</code></pre>"},{"location":"harbor/#adalib.harbor.request_harbor","title":"request_harbor","text":"<pre><code>request_harbor(path, method=requests.get, **kwargs)\n</code></pre> <p>Function to request the registry API at the specified url.</p> <p>Raises on errors from the http calls.</p> <p>Note: All kwargs passed are directly sent through to the request function.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path to query the registry on (base url will be injected automatically)</p> required <code>method</code> <code>function, optional</code> <p>method to use to query harbor, defaults to requests.get</p> <code>get</code> <p>Returns:</p> Type Description <code>response</code> <p>response from harbor</p> Source code in <code>adalib/harbor/harbor.py</code> <pre><code>def request_harbor(\n    path: str,\n    method=requests.get,\n    **kwargs,\n) -&gt; requests.models.Response:\n    \"\"\"Function to request the registry API at the specified url.\n\n    Raises on errors from the http calls.\n\n    Note: All kwargs passed are directly sent through to the request function.\n\n    :param path: path to query the registry on (base url will be injected\n                 automatically)\n    :type path: str\n    :param method: method to use to query harbor, defaults to requests.get\n    :type method: function, optional\n    :return: response from harbor\n    :rtype: response\n    \"\"\"\n    # Construct authentication header for harbor\n    adalib_config = config.get_config()\n    harbor_token = keycloak.get_client_token(\n        audience_client_id=adalib_config.KEYCLOAK_CLIENTS[\"harbor\"]\n    )\n\n    headers = {\n        \"authorization\": f\"Bearer {harbor_token['id_token']}\",\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\",\n    }\n\n    # Query harbor and raise for status\n    constructed_url = (\n        f\"{adalib_config.SERVICES['harbor']['url']}/api/v2.0/{path}\"\n    )\n    response = method(constructed_url, headers=headers, **kwargs)\n    response.raise_for_status()\n\n    return response\n</code></pre>"},{"location":"harbor/#adalib.harbor.restore_image","title":"restore_image","text":"<pre><code>restore_image(metadata_id)\n</code></pre> <p>Restore a previously-archived image in the Harbor registry.</p> <p>Parameters:</p> Name Type Description Default <code>metadata_id</code> <code>int</code> <p>the metadata ID of the image</p> required <p>Returns:</p> Type Description <code>None</code> <p>nothing</p> Source code in <code>adalib/harbor/harbor.py</code> <pre><code>def restore_image(metadata_id: int) -&gt; None:\n    \"\"\"Restore a previously-archived image in the Harbor registry.\n\n    :param metadata_id: the metadata ID of the image\n    :type metadata_id: int\n    :return: nothing\n    :rtype: None\n    \"\"\"\n\n    # Check if image is already visible\n    img_metadata = adaboard.request_adaboard(\n        path=f\"registry/metadata/{metadata_id}\",\n    ).json()\n\n    # If not visible, restore it\n    if img_metadata[\"archived\"]:\n        payload = {\"archived\": False}\n        adaboard.request_adaboard(\n            path=f\"registry/metadata/{metadata_id}/archive\",\n            method=requests.put,\n            json=payload,\n        )\n        return None\n    else:\n        raise RuntimeError(\n            f\"Image with metadata ID {metadata_id} is already visible.\"\n        )\n</code></pre>"},{"location":"harbor/#adalib.harbor.update_image_state","title":"update_image_state","text":"<pre><code>update_image_state(metadata_id)\n</code></pre> <p>Update the \"ready\" state of an image based on its status in the Harbor registry.</p> <p>Parameters:</p> Name Type Description Default <code>metadata_id</code> <code>str</code> <p>the metadata ID of the image</p> required <p>Returns:</p> Type Description <code>str</code> <p>the updated \"ready\" state of the image</p> Source code in <code>adalib/harbor/harbor.py</code> <pre><code>def update_image_state(metadata_id: str) -&gt; str:\n    \"\"\"Update the \"ready\" state of an image based on its status in the Harbor registry.\n\n    :param metadata_id: the metadata ID of the image\n    :type metadata_id: int\n    :return: the updated \"ready\" state of the image\n    :rtype: str\n    \"\"\"\n\n    response = adaboard.request_adaboard(\n        path=f\"registry/metadata/{metadata_id}/ready\", method=requests.put\n    ).json()\n\n    return response[\"ready\"]\n</code></pre>"},{"location":"issues/","title":"<code>adalib.issues</code>","text":"<p>The Issues sub-package exposes the core integrations of the issues in the AdaLab Gallery.</p>"},{"location":"issues/#adalib.issues-functions","title":"Functions","text":""},{"location":"issues/#adalib.issues.create_issue","title":"create_issue","text":"<pre><code>create_issue(card_id, message, username)\n</code></pre> <p>Create a new issue for a specific card in the Gallery.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>int</code> <p>id of the card to assign the issue to</p> required <code>message</code> <code>str</code> <p>message of the new issue</p> required <code>username</code> <code>str</code> <p>the current username (tip: check \"LOGNAME\" environment variable)</p> required <p>Returns:</p> Type Description <code>int</code> <p>id of the new issue</p> Source code in <code>adalib/issues/issues.py</code> <pre><code>def create_issue(card_id: int, message: str, username: str) -&gt; int:\n    \"\"\"\n    Create a new issue for a specific card in the Gallery.\n\n    :param card_id: id of the card to assign the issue to\n    :type card_id: int\n    :param message: message of the new issue\n    :type message: str\n    :param username: the current username (tip: check \"LOGNAME\" environment variable)\n    :type username: str\n    :return: id of the new issue\n    :rtype: int\n    \"\"\"\n\n    timestamp = dt.datetime.utcnow().strftime(\"%Y-%m-%dT%H:%M:%S.%fZ\")\n    payload = {\n        \"card_id\": card_id,\n        \"message\": message,\n        \"reported_by\": username,\n        \"reported_date\": timestamp,\n        \"status\": \"new\",\n    }\n    response = adaboard.request_adaboard(\n        path=\"cardissues\",\n        method=requests.post,\n        json=payload,\n    ).json()\n\n    return response[\"id\"]\n</code></pre>"},{"location":"issues/#adalib.issues.get_issue_data","title":"get_issue_data","text":"<pre><code>get_issue_data(issue_id)\n</code></pre> <p>Get contents and information of a specific issue.</p> <p>Parameters:</p> Name Type Description Default <code>issue_id</code> <code>int</code> <p>id of the issue whose info is to be fetched</p> required <p>Returns:</p> Type Description <code>dict</code> <p>dictionary with the issue's detailed info</p> Source code in <code>adalib/issues/issues.py</code> <pre><code>def get_issue_data(\n    issue_id: int,\n) -&gt; dict[\n    str,\n    int\n    | str\n    | dict[str, str | int]\n    | list[dict[str, int | str | dict[str, int | str]]],\n]:\n    \"\"\"\n    Get contents and information of a specific issue.\n\n    :param issue_id: id of the issue whose info is to be fetched\n    :type issue_id: int\n    :return: dictionary with the issue's detailed info\n    :rtype: dict\n    \"\"\"\n\n    response = adaboard.request_adaboard(\n        path=f\"cardissues/{issue_id}\", method=requests.get\n    ).json()\n\n    return response\n</code></pre>"},{"location":"issues/#adalib.issues.get_issues","title":"get_issues","text":"<pre><code>get_issues()\n</code></pre> <p>Get all the card issues registered in the Gallery.</p> <p>Returns:</p> Type Description <code>list</code> <p>list of dictionaries with issues' main info</p> Source code in <code>adalib/issues/issues.py</code> <pre><code>def get_issues() -&gt; list[dict[str, int | str | dict[str, str | int]]]:\n    \"\"\"\n    Get all the card issues registered in the Gallery.\n\n    :return: list of dictionaries with issues' main info\n    :rtype: list\n    \"\"\"\n\n    response = adaboard.request_adaboard(\n        path=\"cardissues\", method=requests.get\n    ).json()\n\n    return response\n</code></pre>"},{"location":"issues/#adalib.issues.update_issue","title":"update_issue","text":"<pre><code>update_issue(issue_id, new_status='', comment='')\n</code></pre> <p>Update issue content (status, comments). Note that only one of the fields can be updated at a time.</p> <p>Parameters:</p> Name Type Description Default <code>issue_id</code> <code>int</code> <p>the id of the issue to be updated</p> required <code>new_status</code> <code>str</code> <p>status to be set</p> <code>''</code> <code>comment</code> <code>str</code> <p>comment to be added</p> <code>''</code> <p>Returns:</p> Type Description <code>int</code> <p>id of the issue update</p> Source code in <code>adalib/issues/issues.py</code> <pre><code>def update_issue(\n    issue_id: int, new_status: str = \"\", comment: str = \"\"\n) -&gt; int:\n    \"\"\"\n    Update issue content (status, comments).\n    Note that only one of the fields can be updated at a time.\n\n    :param issue_id: the id of the issue to be updated\n    :type issue_id: int\n    :param new_status: status to be set\n    :type new_status: str\n    :param comment: comment to be added\n    :type comment: str\n    :return: id of the issue update\n    :rtype: int\n    \"\"\"\n\n    if comment and not new_status:\n        payload = {\n            \"comment\": comment,\n            \"history_type\": \"comment\",\n        }\n    elif new_status and not comment:\n        assert new_status.lower() in [\n            \"new\",\n            \"in progress\",\n            \"in_progress\",\n            \"solved\",\n            \"ignored\",\n        ], \"Invalid status!\"\n        payload = {\n            \"new_status\": new_status.lower().replace(\" \", \"_\"),\n            \"comment\": \"\",\n            \"history_type\": \"new_status\",\n        }\n    else:\n        return \"Only one field can be updated at a time!\"\n\n    response = adaboard.request_adaboard(\n        path=f\"cardissues/{issue_id}\",\n        method=requests.put,\n        json=payload,\n    ).json()\n\n    return response[\"id\"]\n</code></pre>"},{"location":"jupyterhub/","title":"<code>adalib.jupyterhub</code>","text":"<p>module to work with jupyterhub on the AdaLab platform.</p>"},{"location":"jupyterhub/#adalib.jupyterhub-functions","title":"Functions","text":""},{"location":"jupyterhub/#adalib.jupyterhub.get_token_from_auth_state","title":"get_token_from_auth_state","text":"<pre><code>get_token_from_auth_state(username, jh_token, jh_api_url)\n</code></pre> <p>Get a keycloak token from jupyter auth state.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Token to access jupyterhub.</p> Source code in <code>adalib/jupyterhub/__init__.py</code> <pre><code>def get_token_from_auth_state(\n    username: str,\n    jh_token: str,\n    jh_api_url: str,\n) -&gt; dict:\n    \"\"\"Get a keycloak token from jupyter auth state.\n\n    :return: Token to access jupyterhub.\n    :rtype: dict\n    \"\"\"\n    if jh_api_url.startswith(\"http://\"):\n        os.environ[\"OAUTHLIB_INSECURE_TRANSPORT\"] = \"1\"\n    session = requests_oauthlib.OAuth2Session(token={\"access_token\": jh_token})\n    response = session.get(f\"{jh_api_url}/users/{username}\")\n    response.raise_for_status()\n    user_info = response.json()\n    auth_state = user_info[\"auth_state\"]\n    if not auth_state:\n        raise ValueError(\"No auth state returned by JupyterHub API\")\n    return auth_state\n</code></pre>"},{"location":"jupyterhub/#adalib.jupyterhub.is_this_jupyterhub","title":"is_this_jupyterhub","text":"<pre><code>is_this_jupyterhub()\n</code></pre> <p>Checks whether this package is running in a JupyterHub environment.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>true</code> if called from a program in JupyterHub, <code>false</code> otherwise</p> Source code in <code>adalib/jupyterhub/__init__.py</code> <pre><code>def is_this_jupyterhub():\n    \"\"\"Checks whether this package is running in a JupyterHub environment.\n\n    :return: `true` if called from a program in JupyterHub, `false` otherwise\n    :rtype: bool\n    \"\"\"\n    return \"JUPYTERHUB_API_TOKEN\" in os.environ\n</code></pre>"},{"location":"keycloak/","title":"<code>adalib.keycloak</code>","text":"<p>module to work with the authentication solution on the AdaLab platform.</p>"},{"location":"keycloak/#adalib.keycloak-functions","title":"Functions","text":""},{"location":"keycloak/#adalib.keycloak.app_authentication","title":"app_authentication","text":"<pre><code>app_authentication(audience, scope='openid')\n</code></pre> <p>Returns an audience authentication token from an exchange with an app token.</p> <p>Parameters:</p> Name Type Description Default <code>audience</code> <code>str</code> <p>The audience for which the token is requested.</p> required <code>scope</code> <code>str</code> <p>The scope of the token exchange, defaults to \"openid\"</p> <code>'openid'</code> <p>Returns:</p> Type Description <code>dict</code> <p>The audience token.</p> Source code in <code>adalib/keycloak/__init__.py</code> <pre><code>def app_authentication(audience: str, scope: str = \"openid\") -&gt; dict:\n    \"\"\"\n    Returns an audience authentication token from an exchange with an app token.\n\n    :param audience: The audience for which the token is requested.\n    :type audience: str\n    :param scope: The scope of the token exchange, defaults to \"openid\"\n    :type scope: str, optional\n    :return: The audience token.\n    :rtype: dict\n    \"\"\"\n    adalib_config = get_config()\n    app_token = {\n        \"access_token\": adalib_config.CREDENTIALS[\"app_access_token\"],\n        \"refresh_token\": adalib_config.CREDENTIALS[\"app_refresh_token\"],\n    }\n\n    # Exchange the app token for a Jupyterhub token\n    jh_token = get_token_from_exchange(\n        audience=adalib_config.KEYCLOAK_CLIENTS[\"jupyterhub\"],\n        token=app_token,\n        client_id=adalib_config.CREDENTIALS[\"client_id\"],\n        client_secret=adalib_config.CREDENTIALS[\"client_secret\"],\n        scope=scope,\n    )\n    update_tokens_in_config(\n        new_token=jh_token,\n        client_id=adalib_config.KEYCLOAK_CLIENTS[\"jupyterhub\"],\n    )\n    # Exchange the Jupyterhub token for an audience token\n    audience_token = get_token_from_exchange(\n        audience=audience,\n        token=jh_token,\n        client_id=adalib_config.KEYCLOAK_CLIENTS[\"jupyterhub\"],\n        client_secret=adalib_config.KEYCLOAK_CLIENTS[\"jupyterhub_secret\"],\n        scope=scope,\n    )\n    return audience_token\n</code></pre>"},{"location":"keycloak/#adalib.keycloak.authenticate_with_stored_credentials","title":"authenticate_with_stored_credentials","text":"<pre><code>authenticate_with_stored_credentials(audience_client_id)\n</code></pre> <p>Attempt to get token for audience_client using stored credentials.</p> <p>Parameters:</p> Name Type Description Default <code>audience_client_id</code> <code>str</code> <p>The client ID of the audience.</p> required <p>Returns:</p> Type Description <code>dict | None</code> <p>The token for the current user to authenticate to the audience_client with.</p> Source code in <code>adalib/keycloak/__init__.py</code> <pre><code>def authenticate_with_stored_credentials(\n    audience_client_id: str,\n) -&gt; Union[dict, None]:\n    \"\"\"Attempt to get token for audience_client using stored credentials.\n\n    :param audience_client_id: The client ID of the audience.\n    :type audience_client_id: str\n    :return: The token for the current user to authenticate to the audience_client with.\n    :rtype: dict or None\n    \"\"\"\n    adalib_config = get_config()\n    token = {\n        \"access_token\": adalib_config.CREDENTIALS[\"access_token\"],\n        \"refresh_token\": adalib_config.CREDENTIALS[\"refresh_token\"],\n    }\n    if token[\"access_token\"] is None and token[\"refresh_token\"] is None:\n        logging.debug(\"No stored credentials.\")\n        return None\n    try:\n        audience_token = get_token_from_exchange(\n            audience=audience_client_id,\n            token=token,\n            client_id=adalib_config.KEYCLOAK_CLIENTS[\"jupyterhub\"],\n            client_secret=adalib_config.KEYCLOAK_CLIENTS[\"jupyterhub_secret\"],\n        )\n    except AssertionError:\n        logging.warning(\"Stored credentials are no longer valid.\")\n        return None\n    return audience_token\n</code></pre>"},{"location":"keycloak/#adalib.keycloak.external_authentication","title":"external_authentication","text":"<pre><code>external_authentication(audience, scope='openid')\n</code></pre> <p>Returns an audience authentication token from an exchange with external user credentials.</p> <p>Parameters:</p> Name Type Description Default <code>audience</code> <code>str</code> <p>The audience for which the token is requested.</p> required <code>scope</code> <code>str</code> <p>The scope of the token exchange, defaults to \"openid\"</p> <code>'openid'</code> <p>Returns:</p> Type Description <code>dict</code> <p>The audience token.</p> Source code in <code>adalib/keycloak/__init__.py</code> <pre><code>def external_authentication(audience: str, scope: str = \"openid\") -&gt; dict:\n    \"\"\"\n    Returns an audience authentication token from an exchange with external user credentials.\n\n    :param audience: The audience for which the token is requested.\n    :type audience: str\n    :param scope: The scope of the token exchange, defaults to \"openid\"\n    :type scope: str, optional\n    :return: The audience token.\n    :rtype: dict\n    \"\"\"\n    adalib_config = get_config()\n    jh_client = get_client(\n        client_id=adalib_config.KEYCLOAK_CLIENTS[\"jupyterhub\"],\n        client_secret=adalib_config.KEYCLOAK_CLIENTS[\"jupyterhub_secret\"],\n    )\n    jh_token = jh_client.token(\n        username=adalib_config.CREDENTIALS[\"username\"],\n        password=adalib_config.CREDENTIALS[\"password\"],\n    )\n    update_tokens_in_config(\n        new_token=jh_token,\n        client_id=adalib_config.KEYCLOAK_CLIENTS[\"jupyterhub\"],\n    )\n    audience_token = get_token_from_exchange(\n        audience=audience,\n        token=jh_token,\n        client_id=adalib_config.KEYCLOAK_CLIENTS[\"jupyterhub\"],\n        client_secret=adalib_config.KEYCLOAK_CLIENTS[\"jupyterhub_secret\"],\n        scope=scope,\n    )\n    return audience_token\n</code></pre>"},{"location":"keycloak/#adalib.keycloak.get_client","title":"get_client","text":"<pre><code>get_client(client_id=None, client_secret=None)\n</code></pre> <p>Returns a Keycloak client configured for a specific client. Defaults to the Jupyterhub client.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>The ID of a client that is registered in Keycloak</p> <code>None</code> <code>client_secret</code> <code>str</code> <p>The secret matching the given client ID</p> <code>None</code> <p>Returns:</p> Type Description <code>KeycloakClient</code> <p>Keycloak client for the given client ID.</p> Source code in <code>adalib/keycloak/__init__.py</code> <pre><code>def get_client(\n    client_id: str = None,\n    client_secret: str = None,\n) -&gt; keycloak.KeycloakOpenID:\n    \"\"\"Returns a Keycloak client configured for a specific client. Defaults to\n    the Jupyterhub client.\n\n    :param client_id: The ID of a client that is registered in Keycloak\n    :param client_secret: The secret matching the given client ID\n    :return: Keycloak client for the given client ID.\n    :rtype: KeycloakClient\n    \"\"\"\n    adalib_config = get_config()\n    external = True if adalib_config.ENVIRONMENT == \"external\" else False\n    if external:\n        server_url = adalib_config.SERVICES[\"keycloak\"][\"external\"] + \"/auth/\"\n    else:\n        server_url = adalib_config.SERVICES[\"keycloak\"][\"url\"] + \"/auth/\"\n    return keycloak.KeycloakOpenID(\n        server_url=server_url,\n        client_id=client_id,\n        client_secret_key=client_secret,\n        realm_name=adalib_config.KEYCLOAK_REALM,\n        verify=True,\n    )\n</code></pre>"},{"location":"keycloak/#adalib.keycloak.get_client_token","title":"get_client_token","text":"<pre><code>get_client_token(audience_client_id)\n</code></pre> <p>Get the token for the current user to authenticate to adaboard with depending on adalib's environment configuration.</p> <p>Parameters:</p> Name Type Description Default <code>audience_client_id</code> <code>str</code> <p>The client ID of the audience.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The token for the current user to authenticate to adaboard with.</p> Source code in <code>adalib/keycloak/__init__.py</code> <pre><code>def get_client_token(audience_client_id: str) -&gt; dict:\n    \"\"\"Get the token for the current user to authenticate to adaboard with depending on adalib's\n    environment configuration.\n\n    :param audience_client_id: The client ID of the audience.\n    :type audience_client_id: str\n    :return: The token for the current user to authenticate to adaboard with.\n    :rtype: dict\n    \"\"\"\n\n    # First try to authenticate with stored credentials\n    logging.debug(\"Attempting to authenticate with stored credentials.\")\n    token_from_stored_credentials = authenticate_with_stored_credentials(\n        audience_client_id=audience_client_id\n    )\n    if token_from_stored_credentials is not None:\n        return token_from_stored_credentials\n\n    # If that fails, try to authenticate with user credentials\n    adalib_config = get_config()\n    logging.debug(\"Attempting to authenticate with provided credentials.\")\n    if adalib_config.ENVIRONMENT == \"jupyterhub\":\n        return jupyterhub_authentication(audience=audience_client_id)\n    elif adalib_config.ENVIRONMENT == \"nonpub-user-app\":\n        return app_authentication(audience=audience_client_id)\n    elif adalib_config.ENVIRONMENT == \"external\":\n        return external_authentication(audience=audience_client_id)\n</code></pre>"},{"location":"keycloak/#adalib.keycloak.get_token_from_exchange","title":"get_token_from_exchange","text":"<pre><code>get_token_from_exchange(audience, token, client_id, client_secret, scope='openid')\n</code></pre> <p>Get a token for the audience given a valid client token.</p> <p>Note for developers: The scope defaults to <code>openid</code> to be consistent with the subsequent call to <code>keycloakOpenID.exchange_token(...)</code>. If this default is changed it should be done so with respect to this underlying method.</p> <p>Parameters:</p> Name Type Description Default <code>audience</code> <code>str</code> <p>Client that we need to get a token for.</p> required <code>scope</code> <code>str</code> <p>Scope of token requested, defaults to \"\"</p> <code>'openid'</code> <p>Returns:</p> Type Description <code>dict</code> <p>Token to access audience</p> Source code in <code>adalib/keycloak/__init__.py</code> <pre><code>def get_token_from_exchange(\n    audience: str,\n    token: str,\n    client_id: str,\n    client_secret: str,\n    scope: str = \"openid\",\n) -&gt; dict:\n    \"\"\"Get a token for the audience given a valid client token.\n\n    Note for developers: The scope defaults to `openid` to be consistent with the\n    subsequent call to `keycloakOpenID.exchange_token(...)`. If this default is\n    changed it should be done so with respect to this underlying method.\n\n    :param audience: Client that we need to get a token for.\n    :type audience: str\n    :param scope: Scope of token requested, defaults to \"\"\n    :type scope: str, optional\n    :return: Token to access audience\n    :rtype: dict\n    \"\"\"\n    client = get_client(client_id=client_id, client_secret=client_secret)\n    if not client.introspect(token=token[\"access_token\"])[\"active\"]:\n        assert (\n            \"refresh_token\" in token and token[\"refresh_token\"] is not None\n        ), \"Access token is no longer valid and a refresh token was not provided\"\n        try:\n            token = client.refresh_token(refresh_token=token[\"refresh_token\"])\n        except Exception as exc:\n            raise AssertionError(\"Refresh token has expired.\") from exc\n        update_tokens_in_config(new_token=token, client_id=client_id)\n\n    audience_token = client.exchange_token(\n        token=token[\"access_token\"],\n        audience=audience,\n        subject=None,\n        scope=scope,\n    )\n    return audience_token\n</code></pre>"},{"location":"keycloak/#adalib.keycloak.jupyterhub_authentication","title":"jupyterhub_authentication","text":"<pre><code>jupyterhub_authentication(audience, scope='openid')\n</code></pre> <p>Returns an audience authentication token from an exchange with a Jupyterhub token.</p> <p>Parameters:</p> Name Type Description Default <code>audience</code> <code>str</code> <p>The audience for which the token is requested.</p> required <code>scope</code> <code>str</code> <p>The scope of the token exchange, defaults to \"openid\"</p> <code>'openid'</code> <p>Returns:</p> Type Description <code>dict</code> <p>The audience token.</p> Source code in <code>adalib/keycloak/__init__.py</code> <pre><code>def jupyterhub_authentication(audience: str, scope: str = \"openid\") -&gt; dict:\n    \"\"\"\n    Returns an audience authentication token from an exchange with a Jupyterhub token.\n\n    :param audience: The audience for which the token is requested.\n    :type audience: str\n    :param scope: The scope of the token exchange, defaults to \"openid\"\n    :type scope: str, optional\n    :return: The audience token.\n    :rtype: dict\n    \"\"\"\n    adalib_config = get_config()\n    jh_token = jupyterhub.get_token_from_auth_state(\n        username=adalib_config.CREDENTIALS[\"username\"],\n        jh_token=adalib_config.CREDENTIALS[\"jh_token\"],\n        jh_api_url=adalib_config.SERVICES[\"jupyterhub\"][\"url\"] + \"/hub/api\",\n    )\n    update_tokens_in_config(\n        new_token=jh_token,\n        client_id=adalib_config.KEYCLOAK_CLIENTS[\"jupyterhub\"],\n    )\n    audience_token = get_token_from_exchange(\n        audience=audience,\n        token=jh_token,\n        client_id=adalib_config.KEYCLOAK_CLIENTS[\"jupyterhub\"],\n        client_secret=adalib_config.KEYCLOAK_CLIENTS[\"jupyterhub_secret\"],\n        scope=scope,\n    )\n    return audience_token\n</code></pre>"},{"location":"keycloak/#adalib.keycloak.update_tokens_in_config","title":"update_tokens_in_config","text":"<pre><code>update_tokens_in_config(new_token, client_id)\n</code></pre> <p>Update the tokens in the config object.</p> <p>Parameters:</p> Name Type Description Default <code>new_token</code> <code>dict</code> <p>The new token to update the config with.</p> required <code>client_id</code> <code>str</code> <p>The client ID of the client that the token is for.</p> required Source code in <code>adalib/keycloak/__init__.py</code> <pre><code>def update_tokens_in_config(new_token: dict, client_id: str):\n    \"\"\"Update the tokens in the config object.\n\n    :param new_token: The new token to update the config with.\n    :type new_token: dict\n    :param client_id: The client ID of the client that the token is for.\n    :type client_id: str\n    \"\"\"\n    adalib_config = get_config()\n    if client_id == adalib_config.KEYCLOAK_CLIENTS[\"jupyterhub\"]:\n        adalib_config.CREDENTIALS[\"access_token\"] = new_token[\"access_token\"]\n        adalib_config.CREDENTIALS[\"refresh_token\"] = new_token[\"refresh_token\"]\n</code></pre>"},{"location":"keywords/","title":"<code>adalib.keywords</code>","text":"<p>The Keywords sub-package exposes the core integrations of the keywords in the AdaLab Gallery.</p>"},{"location":"keywords/#adalib.keywords-functions","title":"Functions","text":""},{"location":"keywords/#adalib.keywords.create_keywords","title":"create_keywords","text":"<pre><code>create_keywords(new_keywords)\n</code></pre> <p>Add a new keyword to the Gallery.</p> <p>Parameters:</p> Name Type Description Default <code>new_keyword</code> <code>str | list</code> <p>name (or names) of the keywords to be added</p> required <p>Returns:</p> Type Description <code>list</code> <p>a list of dictionaries with the new keyword ids</p> Source code in <code>adalib/keywords/keywords.py</code> <pre><code>def create_keywords(\n    new_keywords: str | list[str],\n) -&gt; list[dict[str, str | int]]:\n    \"\"\"\n    Add a new keyword to the Gallery.\n\n    :param new_keyword: name (or names) of the keywords to be added\n    :type new_keyword: str or list\n    :return: a list of dictionaries with the new keyword ids\n    :rtype: list\n    \"\"\"\n\n    if not isinstance(new_keywords, list):\n        new_keywords = [new_keywords]\n\n    new_keyword_ids = []\n    for new_keyword in new_keywords:\n        payload = {\"keyword\": new_keyword}\n        response = adaboard.request_adaboard(\n            path=\"keywords\",\n            method=requests.post,\n            json=payload,\n        ).json()\n\n        new_keyword_ids.append(\n            {\"keyword\": new_keyword, \"keyword_id\": response[\"id\"]}\n        )\n    return new_keyword_ids\n</code></pre>"},{"location":"keywords/#adalib.keywords.delete_keywords","title":"delete_keywords","text":"<pre><code>delete_keywords(keywords)\n</code></pre> <p>Delete keywords from the Gallery.</p> <p>Parameters:</p> Name Type Description Default <code>keywords</code> <code>str | list[str]</code> <p>keywords to be deleted (tip: all names must be valid, otherwise the process fails)</p> required <p>Returns:</p> Type Description <code>None</code> <p>Nothing</p> Source code in <code>adalib/keywords/keywords.py</code> <pre><code>def delete_keywords(keywords: str | list[str]) -&gt; None:\n    \"\"\"\n    Delete keywords from the Gallery.\n\n    :param keywords: keywords to be deleted (tip: all names must be valid, otherwise the process fails)\n    :type keywords: str or list\n    :return: Nothing\n    :rtype: None\n    \"\"\"\n\n    if not isinstance(keywords, list):\n        keywords = [keywords]\n\n    keyword_ids = []\n    for keyword in keywords:\n        kw_id = get_keyword_id(keyword=keyword)\n        keyword_ids.append(str(kw_id))\n    delete_keywords_by_id(keyword_ids=keyword_ids)\n\n    return None\n</code></pre>"},{"location":"keywords/#adalib.keywords.delete_keywords_by_id","title":"delete_keywords_by_id","text":"<pre><code>delete_keywords_by_id(keyword_ids)\n</code></pre> <p>Delete keywords from the Gallery based on their ids.</p> <p>Parameters:</p> Name Type Description Default <code>keyword_ids</code> <code>str | list[str]</code> <p>ids of the keywords to be deleted (tip: all ids must be valid, otherwise the process fails)</p> required <p>Returns:</p> Type Description <code>None</code> <p>Nothing</p> Source code in <code>adalib/keywords/keywords.py</code> <pre><code>def delete_keywords_by_id(keyword_ids: str | list[str]) -&gt; None:\n    \"\"\"\n    Delete keywords from the Gallery based on their ids.\n\n    :param keyword_ids: ids of the keywords to be deleted (tip: all ids must be valid, otherwise the process fails)\n    :type keyword_ids: str or list\n    :return: Nothing\n    :rtype: None\n    \"\"\"\n\n    if not isinstance(keyword_ids, list):\n        keyword_ids = [keyword_ids]\n\n    payload = {\"keyword_ids\": keyword_ids}\n    adaboard.request_adaboard(\n        path=\"keywords\",\n        method=requests.delete,\n        json=payload,\n    )\n\n    return None\n</code></pre>"},{"location":"keywords/#adalib.keywords.get_keyword_id","title":"get_keyword_id","text":"<pre><code>get_keyword_id(keyword)\n</code></pre> <p>Find the id for a specific keyword.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>name of the keyword</p> required <p>Returns:</p> Type Description <code>int | None</code> <p>id of the keyword, or None if keyword not found</p> Source code in <code>adalib/keywords/keywords.py</code> <pre><code>def get_keyword_id(keyword: str) -&gt; int | None:\n    \"\"\"\n    Find the id for a specific keyword.\n\n    :param keyword: name of the keyword\n    :type keyword: str\n    :return: id of the keyword, or None if keyword not found\n    :rtype: int or None\n    \"\"\"\n\n    kws = get_keywords()\n    for kw in kws:\n        if keyword == kw[\"keyword\"]:\n            return kw[\"keyword_id\"]\n    return None\n</code></pre>"},{"location":"keywords/#adalib.keywords.get_keywords","title":"get_keywords","text":"<pre><code>get_keywords()\n</code></pre> <p>Get information about all keywords in the Gallery.</p> <p>Returns:</p> Type Description <code>list</code> <p>list of dictionaries with keywords data</p> Source code in <code>adalib/keywords/keywords.py</code> <pre><code>def get_keywords() -&gt; list[dict[str, str | int]]:\n    \"\"\"\n    Get information about all keywords in the Gallery.\n\n    :return: list of dictionaries with keywords data\n    :rtype: list\n    \"\"\"\n\n    response = adaboard.request_adaboard(\n        path=\"keywords\",\n        method=requests.get,\n    ).json()\n\n    return response\n</code></pre>"},{"location":"keywords/#adalib.keywords.get_keywords_stats","title":"get_keywords_stats","text":"<pre><code>get_keywords_stats()\n</code></pre> <p>Get utilization statistics for the keywords in the Gallery.</p> <p>Returns:</p> Type Description <code>list</code> <p>list of dictionaries with keywords stats</p> Source code in <code>adalib/keywords/keywords.py</code> <pre><code>def get_keywords_stats() -&gt; list[dict[str, str | int]]:\n    \"\"\"\n    Get utilization statistics for the keywords in the Gallery.\n\n    :return: list of dictionaries with keywords stats\n    :rtype: list\n    \"\"\"\n\n    response = adaboard.request_adaboard(\n        path=\"keywords/statistics\",\n        method=requests.get,\n    ).json()\n\n    return response\n</code></pre>"},{"location":"keywords/#adalib.keywords.merge_keywords","title":"merge_keywords","text":"<pre><code>merge_keywords(keywords, new_keyword)\n</code></pre> <p>Merge several keywords into a single one.</p> <p>Parameters:</p> Name Type Description Default <code>keywords</code> <code>list[str]</code> <p>keywords to be merged</p> required <code>new_keyword</code> <code>str</code> <p>name of the new keyword (note: it can be one of the keywords to be merged)</p> required <p>Returns:</p> Type Description <code>int</code> <p>the new keyword's id</p> Source code in <code>adalib/keywords/keywords.py</code> <pre><code>def merge_keywords(keywords: list[str], new_keyword: str) -&gt; dict[str, int]:\n    \"\"\"\n    Merge several keywords into a single one.\n\n    :param keywords: keywords to be merged\n    :type keywords: list\n    :param new_keyword: name of the new keyword (note: it can be one of the keywords to be merged)\n    :type new_keyword: str\n    :return: the new keyword's id\n    :rtype: int\n    \"\"\"\n\n    keyword_ids = []\n    for keyword in keywords:\n        kw_id = get_keyword_id(keyword=keyword)\n        keyword_ids.append(kw_id)\n\n    payload = {\"keyword_ids\": keyword_ids, \"new_keyword\": new_keyword}\n    response = adaboard.request_adaboard(\n        path=\"keywords/merge\",\n        method=requests.put,\n        json=payload,\n    ).json()\n\n    return response[\"id\"]\n</code></pre>"},{"location":"keywords/#adalib.keywords.rename_keyword","title":"rename_keyword","text":"<pre><code>rename_keyword(keyword, new_keyword)\n</code></pre> <p>Rename a keyword.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>the keyword to be renamed</p> required <code>new_keyword</code> <code>str</code> <p>name of the new keyword</p> required <p>Returns:</p> Type Description <code>int</code> <p>new keyword's id</p> Source code in <code>adalib/keywords/keywords.py</code> <pre><code>def rename_keyword(keyword: str, new_keyword: str) -&gt; int | str:\n    \"\"\"\n    Rename a keyword.\n\n    :param keyword: the keyword to be renamed\n    :type keyword: str\n    :param new_keyword: name of the new keyword\n    :type new_keyword: str\n    :return: new keyword's id\n    :rtype: int\n    \"\"\"\n\n    keyword_id = get_keyword_id(keyword=keyword)\n    payload = {\"keyword_ids\": [keyword_id], \"new_keyword\": new_keyword}\n    response = adaboard.request_adaboard(\n        path=\"keywords/merge\",\n        method=requests.put,\n        json=payload,\n    ).json()\n\n    return response[\"id\"]\n</code></pre>"},{"location":"lab/","title":"<code>adalib.lab</code>","text":"<p>The Lab sub-package exposes the core integrations of the user's Lab environment in AdaLab.</p>"},{"location":"lab/#adalib.lab-functions","title":"Functions","text":""},{"location":"lab/#adalib.lab.build_image_from_git","title":"build_image_from_git","text":"<pre><code>build_image_from_git(git_url, git_type, image_name, image_tag, build_args={}, timeout=3600, project_name='kernels', is_docker=False, git_creds={})\n</code></pre> <p>Build a container image from a Containerfile in a Git repository.</p> <p>Parameters:</p> Name Type Description Default <code>git_url</code> <code>str</code> <p>full URL of Git repository containing the Containerfile</p> required <code>git_type</code> <code>str</code> <p>type of Git repository, either \"SSH\" or \"HTTPS\" or \"public\"</p> required <code>image_name</code> <code>str</code> <p>the name of the target image image</p> required <code>image_tag</code> <code>str</code> <p>the tag of the target image image</p> required <code>build_args</code> <code>dict[str, str]</code> <p>additional build arguments to pass build process, defaults to {}</p> <code>{}</code> <code>timeout</code> <code>int</code> <p>the maximum time (in seconds) to wait for the build to complete, defaults to 3600</p> <code>3600</code> <code>project_name</code> <code>str</code> <p>the name of the project to which the image will be pushed, defaults to \"kernels\"</p> <code>'kernels'</code> <code>is_docker</code> <code>bool</code> <p>whether the original file is a Dockerfile, defaults to False</p> <code>False</code> <code>git_creds</code> <code>dict[str, str]</code> <p>credentials to authenticate to the Git repository. For SSH, use keys \"PRIVATE_KEY_FILE\" and \"PASSWORD\". For HTTPS, use keys \"USERNAME\" and \"PASSWORD\".</p> <code>{}</code> <p>Returns:</p> Type Description <code>int</code> <p>the run ID of the build process</p> Source code in <code>adalib/lab/lab.py</code> <pre><code>def build_image_from_git(\n    git_url: str,\n    git_type: str,\n    image_name: str,\n    image_tag: str,\n    build_args: dict[str, str] = {},\n    timeout: int = 3600,\n    project_name: str = \"kernels\",\n    is_docker: bool = False,\n    git_creds: dict[str, str] = {},\n) -&gt; int:\n    \"\"\"Build a container image from a Containerfile in a Git repository.\n\n    :param git_url: full URL of Git repository containing the Containerfile\n    :type git_url: str\n    :param git_type: type of Git repository, either \"SSH\" or \"HTTPS\" or \"public\"\n    :type git_type: str\n    :param image_name: the name of the target image image\n    :type image_name: str\n    :param image_tag: the tag of the target image image\n    :type image_tag: str\n    :param build_args: additional build arguments to pass build process, defaults to {}\n    :type build_args: dict, optional\n    :param timeout: the maximum time (in seconds) to wait for the build to complete, defaults to 3600\n    :type timeout: int, optional\n    :param project_name: the name of the project to which the image will be pushed, defaults to \"kernels\"\n    :type project_name: str, optional\n    :param is_docker: whether the original file is a Dockerfile, defaults to False\n    :type is_docker: bool, optional\n    :param git_creds: credentials to authenticate to the Git repository. For SSH, use keys \"PRIVATE_KEY_FILE\" and \"PASSWORD\". For HTTPS, use keys \"USERNAME\" and \"PASSWORD\".\n    :type git_creds: dict, optional\n    :return: the run ID of the build process\n    :rtype: int\n    \"\"\"\n\n    adalib_config = get_config()\n    # Check that the specified project is valid\n    assert (\n        project_name in ALLOWED_OCI_PROJECT_TYPES\n    ), f\"Can only build images that are of the type {', '.join([x for x in ALLOWED_OCI_PROJECT_TYPES])}\"\n    assert (\n        git_type.lower() in ALLOWED_GIT_TYPES\n    ), f\"Git type must be one of {', '.join([x for x in ALLOWED_GIT_TYPES])}\"\n\n    # Build request payload with the specified parameters\n    # Prepare build arguments\n    build_args = \";;\".join([f\"{k}={v}\" for k, v in build_args.items()])\n    # Set correct Containerfile type\n    file_type = \"Dockerfile\" if is_docker else \"Containerfile\"\n    # Collect parameters into payload\n    payload = {\n        \"script\": \"builder\",\n        \"user_id\": adaboard.get_user()[\"user_id\"],\n        \"pool\": \"internal\",\n        \"cleanup\": True,\n        \"timeout\": timeout,\n        \"run_in_isolation\": False,\n        \"start_podman_sidecar\": False,\n        \"config\": {\n            \"HARBOR_CURATED_PROJECT\": {\n                \"real_value\": project_name,\n                \"value\": project_name,\n            },\n            \"HARBOR_HOST\": {\n                \"real_value\": HARBOR_HOST,\n                \"value\": HARBOR_HOST,\n            },\n            \"HARBOR_HUMAN_READABLE_REPOSITORY_NAME\": {\n                \"real_value\": image_name,\n                \"value\": image_name,\n            },\n            \"HARBOR_NAMESPACE\": {\n                \"real_value\": adalib_config.NAMESPACE,\n                \"value\": adalib_config.NAMESPACE,\n            },\n            \"HARBOR_PROJECT\": {\n                \"real_value\": \"kernels_temp\",\n                \"value\": \"kernels_temp\",\n            },\n            \"HARBOR_REPOSITORY_NAME\": {\n                \"real_value\": image_name,\n                \"value\": image_name,\n            },\n            \"HARBOR_TAG\": {\n                \"real_value\": image_tag,\n                \"value\": image_tag,\n            },\n            \"IMAGE_BUILD_ARGS\": {\n                \"real_value\": build_args,\n                \"value\": build_args,\n            },\n            \"IMAGE_CONTAINERFILE_LOCATION\": {\n                \"real_value\": file_type,\n                \"value\": file_type,\n            },\n            \"NETWORK_HOST\": {\n                \"real_value\": adalib_config.NETWORK_HOST,\n                \"value\": adalib_config.NETWORK_HOST,\n            },\n        },\n    }\n\n    # Add Git credentials to payload based on Git type\n    if git_type.lower() == \"ssh\":\n        assert list(git_creds.keys()) == [\n            \"PRIVATE_KEY_FILE\",\n            \"PASSWORD\",\n        ], \"For SSH, please provide the keys 'PRIVATE_KEY_FILE' and 'PASSWORD' in the 'git_creds' dictionary.\"\n        git_url = git_url.replace(\"https://\", \"git@\").replace(\".com/\", \".com:\")\n        git_config = [\n            {\n                \"GIT_URL\": {\"real_value\": git_url, \"value\": git_url},\n                \"GIT_SSH_PRIVATE_KEY_FILE\": {\n                    \"real_value\": git_creds[\"PRIVATE_KEY_FILE\"],\n                    \"value\": git_creds[\"PRIVATE_KEY_FILE\"],\n                },\n                \"GIT_SSH_PASSWORD\": {\n                    \"real_value\": git_creds[\"PASSWORD\"],\n                    \"value\": git_creds[\"PASSWORD\"],\n                },\n            },\n        ]\n    elif git_type.lower() == \"https\":\n        assert list(git_creds.keys()) == [\n            \"USERNAME\",\n            \"PASSWORD\",\n        ], \"For HTTPS, please provide the keys 'USERNAME' and 'PASSWORD' in the 'git_creds' dictionary.\"\n        git_config = [\n            {\n                \"GIT_URL\": {\"real_value\": git_url, \"value\": git_url},\n                \"GIT_USERNAME\": {\n                    \"real_value\": git_creds[\"USERNAME\"],\n                    \"value\": git_creds[\"USERNAME\"],\n                },\n                \"GIT_PASSWORD\": {\n                    \"real_value\": git_creds[\"PASSWORD\"],\n                    \"value\": git_creds[\"PASSWORD\"],\n                },\n            },\n        ]\n    elif git_type.lower() == \"public\":\n        git_config = [\n            {\n                \"GIT_URL\": {\"real_value\": git_url, \"value\": git_url},\n            },\n        ]\n\n    for item in git_config:\n        payload[\"config\"].update(item)\n\n    # Trigger the build and get the run ID\n    response_build = adaboard.request_adaboard(\n        path=\"script_runner/runs/start/\",\n        method=requests.post,\n        json=payload,\n    ).json()\n\n    return response_build[\"id\"]\n</code></pre>"},{"location":"lab/#adalib.lab.build_image_from_lab","title":"build_image_from_lab","text":"<pre><code>build_image_from_lab(source_repository, image_name, image_tag, build_args={}, timeout=3600, project_name='kernels', is_docker=False)\n</code></pre> <p>Build a container image from a Containerfile in the Lab.</p> <p>Parameters:</p> Name Type Description Default <code>source_repository</code> <code>str</code> <p>Lab directory containing the Containerfile</p> required <code>image_name</code> <code>str</code> <p>the name of the target image image</p> required <code>image_tag</code> <code>str</code> <p>the tag of the target image image</p> required <code>build_args</code> <code>dict[str, str]</code> <p>additional build arguments to pass build process, defaults to {}</p> <code>{}</code> <code>timeout</code> <code>int</code> <p>the maximum time (in seconds) to wait for the build to complete, defaults to 3600</p> <code>3600</code> <code>project_name</code> <code>str</code> <p>the name of the project to which the image will be pushed, defaults to \"kernels\"</p> <code>'kernels'</code> <code>is_docker</code> <code>bool</code> <p>whether the original file is a Dockerfile, defaults to False</p> <code>False</code> <p>Returns:</p> Type Description <code>int</code> <p>the run ID of the build process</p> Source code in <code>adalib/lab/lab.py</code> <pre><code>def build_image_from_lab(\n    source_repository: str,\n    image_name: str,\n    image_tag: str,\n    build_args: dict[str, str] = {},\n    timeout: int = 3600,\n    project_name: str = \"kernels\",\n    is_docker: bool = False,\n) -&gt; int:\n    \"\"\"Build a container image from a Containerfile in the Lab.\n\n    :param source_repository: Lab directory containing the Containerfile\n    :type source_repository: str\n    :param image_name: the name of the target image image\n    :type image_name: str\n    :param image_tag: the tag of the target image image\n    :type image_tag: str\n    :param build_args: additional build arguments to pass build process, defaults to {}\n    :type build_args: dict, optional\n    :param timeout: the maximum time (in seconds) to wait for the build to complete, defaults to 3600\n    :type timeout: int, optional\n    :param project_name: the name of the project to which the image will be pushed, defaults to \"kernels\"\n    :type project_name: str, optional\n    :param is_docker: whether the original file is a Dockerfile, defaults to False\n    :type is_docker: bool, optional\n    :return: the run ID of the build process\n    :rtype: int\n    \"\"\"\n\n    adalib_config = get_config()\n    # Check that the specified project is valid\n    assert (\n        project_name in ALLOWED_OCI_PROJECT_TYPES\n    ), f\"Can only build images that are of the type {', '.join([x for x in ALLOWED_OCI_PROJECT_TYPES])}\"\n\n    # Build request payload with the specified parameters\n    build_args = \";;\".join([f\"{k}={v}\" for k, v in build_args.items()])\n    file_type = \"Dockerfile\" if is_docker else \"Containerfile\"\n    payload = {\n        \"script\": \"builder\",\n        \"user_id\": adaboard.get_user()[\"user_id\"],\n        \"pool\": \"internal\",\n        \"cleanup\": True,\n        \"timeout\": timeout,\n        \"run_in_isolation\": False,\n        \"start_podman_sidecar\": False,\n        \"config\": {\n            \"GIT_LOCATION\": {\n                \"real_value\": source_repository,\n                \"value\": source_repository,\n            },\n            \"HARBOR_CURATED_PROJECT\": {\n                \"real_value\": project_name,\n                \"value\": project_name,\n            },\n            \"HARBOR_HOST\": {\n                \"real_value\": HARBOR_HOST,\n                \"value\": HARBOR_HOST,\n            },\n            \"HARBOR_HUMAN_READABLE_REPOSITORY_NAME\": {\n                \"real_value\": image_name,\n                \"value\": image_name,\n            },\n            \"HARBOR_NAMESPACE\": {\n                \"real_value\": adalib_config.NAMESPACE,\n                \"value\": adalib_config.NAMESPACE,\n            },\n            \"HARBOR_PROJECT\": {\n                \"real_value\": \"kernels_temp\",\n                \"value\": \"kernels_temp\",\n            },\n            \"HARBOR_REPOSITORY_NAME\": {\n                \"real_value\": image_name,\n                \"value\": image_name,\n            },\n            \"HARBOR_TAG\": {\n                \"real_value\": image_tag,\n                \"value\": image_tag,\n            },\n            \"IMAGE_BUILD_ARGS\": {\n                \"real_value\": build_args,\n                \"value\": build_args,\n            },\n            \"IMAGE_CONTAINERFILE_LOCATION\": {\n                \"real_value\": file_type,\n                \"value\": file_type,\n            },\n            \"NETWORK_HOST\": {\n                \"real_value\": adalib_config.NETWORK_HOST,\n                \"value\": adalib_config.NETWORK_HOST,\n            },\n        },\n    }\n\n    # Trigger the build and get the run ID\n    response_build = adaboard.request_adaboard(\n        path=\"script_runner/runs/start/\",\n        method=requests.post,\n        json=payload,\n    ).json()\n\n    return response_build[\"id\"]\n</code></pre>"},{"location":"lab/#adalib.lab.download_file","title":"download_file","text":"<pre><code>download_file(file_path, target_path)\n</code></pre> <p>Download a file from the user's Lab environment and save it to a specific location.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>path to the file in the Lab environment, including file name and extension, relative to the user's home directory (/home/) required <code>target_path</code> <code>str</code> <p>path to save the file to, including file name and extension, relative to the current working directory</p> required <p>Returns:</p> Type Description <code>None</code> <p>nothing</p> Source code in <code>adalib/lab/lab.py</code> <pre><code>def download_file(file_path: str, target_path: str) -&gt; None:\n    \"\"\"Download a file from the user's Lab environment and save it to a specific location.\n\n    :param file_path: path to the file in the Lab environment, including file name and extension, relative to the user's home directory (/home/&lt;username&gt;)\n    :type file_path: str\n    :param target_path: path to save the file to, including file name and extension, relative to the current working directory\n    :type target_path: str\n    :return: nothing\n    :rtype: None\n    \"\"\"\n\n    # Get the file, base64 encoded\n    response = adaboard.request_adaboard(\n        path=f\"jupyter/files/notebook/content/fetch?path={file_path}\",\n    ).json()\n\n    # Decode the file to get the binary\n    file_bytes = base64.b64decode(response[\"content\"])\n\n    # Write the file to the target path\n    with open(target_path, \"wb\") as out_file:\n        out_file.write(file_bytes)\n\n    return None\n</code></pre>"},{"location":"lab/#adalib.lab.get_available_kernels","title":"get_available_kernels","text":"<pre><code>get_available_kernels()\n</code></pre> <p>Get a list of available kernel images in the Harbor registry.</p> <p>Returns:</p> Type Description <code>list</code> <p>a list of available kernels</p> Source code in <code>adalib/lab/lab.py</code> <pre><code>def get_available_kernels() -&gt; (\n    list[dict[str, str | int | bool | dict[str, str]]]\n):\n    \"\"\"Get a list of available kernel images in the Harbor registry.\n\n    :return: a list of available kernels\n    :rtype: list\n    \"\"\"\n\n    # Get metadata for all images\n    response = adaboard.request_adaboard(path=\"registry/metadata\").json()\n\n    # Filter-out non-kernel images\n    return [x for x in response if x[\"type\"] == \"kernel\"]\n</code></pre>"},{"location":"lab/#adalib.lab.get_build_status","title":"get_build_status","text":"<pre><code>get_build_status(build_id)\n</code></pre> <p>Get the status of a build process.</p> <p>Parameters:</p> Name Type Description Default <code>build_id</code> <code>int</code> <p>the run ID of the build process</p> required <p>Returns:</p> Type Description <code>str</code> <p>the status of the build process</p> Source code in <code>adalib/lab/lab.py</code> <pre><code>def get_build_status(\n    build_id: int,\n) -&gt; str:\n    \"\"\"Get the status of a build process.\n\n    :param build_id: the run ID of the build process\n    :type build_id: int\n    :return: the status of the build process\n    :rtype: str\n    \"\"\"\n\n    response_statuses = adaboard.request_adaboard(path=\"runner/status/\").json()\n\n    response_run = adaboard.request_adaboard(\n        path=f\"script_runner/runs/{build_id}/\"\n    ).json()\n\n    return response_statuses[str(response_run[\"status\"])]\n</code></pre>"},{"location":"lab/#adalib.lab.get_config_options","title":"get_config_options","text":"<pre><code>get_config_options()\n</code></pre> <p>Get the available Lab configuration options for the user.</p> <p>Returns:</p> Type Description <code>list</code> <p>list of existing Lab configuration options</p> Source code in <code>adalib/lab/lab.py</code> <pre><code>def get_config_options() -&gt; (\n    list[dict[str, int | str | list[dict[str, str | int | bool]]]]\n):\n    \"\"\"Get the available Lab configuration options for the user.\n\n    :return: list of existing Lab configuration options\n    :rtype: list\n    \"\"\"\n\n    response = adaboard.request_adaboard(path=\"jupyter/system/options\").json()\n\n    return response\n</code></pre>"},{"location":"lab/#adalib.lab.get_installed_kernels","title":"get_installed_kernels","text":"<pre><code>get_installed_kernels()\n</code></pre> <p>Get a list of the kernels that are installed in the user's Lab environment.</p> <p>Returns:</p> Type Description <code>list</code> <p>a list of installed kernels</p> Source code in <code>adalib/lab/lab.py</code> <pre><code>def get_installed_kernels() -&gt; list[dict[str, str | int]]:\n    \"\"\"Get a list of the kernels that are installed in the user's Lab environment.\n\n    :return: a list of installed kernels\n    :rtype: list\n    \"\"\"\n\n    response = adaboard.request_adaboard(path=\"jupyter/kernelspecs\").json()\n\n    return response\n</code></pre>"},{"location":"lab/#adalib.lab.get_kernel_metadata_id","title":"get_kernel_metadata_id","text":"<pre><code>get_kernel_metadata_id(kernel_name, kernel_tag)\n</code></pre> <p>Get the metadata ID of the object corresponding to a specific kernel image.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_name</code> <code>str</code> <p>the name of the repository containing the kernel image</p> required <code>kernel_tag</code> <code>str</code> <p>the tag of the kernel image</p> required <p>Returns:</p> Type Description <code>int</code> <p>the metadata ID of the kernel image</p> Source code in <code>adalib/lab/lab.py</code> <pre><code>def get_kernel_metadata_id(kernel_name: str, kernel_tag: str) -&gt; int:\n    \"\"\"Get the metadata ID of the object corresponding to a specific kernel image.\n\n    :param kernel_name: the name of the repository containing the kernel image\n    :type kernel_name: str\n    :param kernel_tag: the tag of the kernel image\n    :type kernel_tag: str\n    :return: the metadata ID of the kernel image\n    :rtype: int\n    \"\"\"\n\n    # Get metadata for all images\n    response = adaboard.request_adaboard(path=\"registry/metadata\").json()\n\n    # Filter-out non-kernel images\n    kernel_images = [x for x in response if x[\"type\"] == \"kernel\"]\n\n    # Return the metadata ID of the specified kernel image, if it exists\n    try:\n        return [\n            x[\"metadata_id\"]\n            for x in kernel_images\n            if x[\"oci_image_name\"][\"repository\"] == kernel_name\n            and x[\"oci_image_name\"][\"tag\"] == kernel_tag\n        ][0]\n    except IndexError:\n        raise ValueError(\n            f\"Kernel image {kernel_name}:{kernel_tag} does not exist.\"\n        )\n</code></pre>"},{"location":"lab/#adalib.lab.get_lab_files","title":"get_lab_files","text":"<pre><code>get_lab_files(path)\n</code></pre> <p>Get a list of the files under a directory in the user's Lab environment.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path to list the files from, relative to the user's home directory (/home/) required <p>Returns:</p> Type Description <code>list</code> <p>files in the directory</p> Source code in <code>adalib/lab/lab.py</code> <pre><code>def get_lab_files(path: str) -&gt; list[dict[str, str | int]]:\n    \"\"\"Get a list of the files under a directory in the user's Lab environment.\n\n    :param path: path to list the files from, relative to the user's home directory (/home/&lt;username&gt;)\n    :type path: str\n    :return: files in the directory\n    :rtype: list\n    \"\"\"\n\n    response = adaboard.request_adaboard(\n        path=f\"jupyter/files/notebook/content/?path={path}\"\n    ).json()\n\n    return response\n</code></pre>"},{"location":"lab/#adalib.lab.get_lab_images","title":"get_lab_images","text":"<pre><code>get_lab_images()\n</code></pre> <p>Get a list of container images present in the user's Lab environment.</p> <p>Returns:</p> Type Description <code>list</code> <p>a list of available images</p> Source code in <code>adalib/lab/lab.py</code> <pre><code>def get_lab_images() -&gt; list[dict[str, str]]:\n    \"\"\"Get a list of container images present in the user's Lab environment.\n\n    :return: a list of available images\n    :rtype: list\n    \"\"\"\n\n    response = adaboard.request_adaboard(path=\"registry/jupyter_images\").json()\n\n    return response\n</code></pre>"},{"location":"lab/#adalib.lab.get_lab_logs","title":"get_lab_logs","text":"<pre><code>get_lab_logs(since=3600, system=False)\n</code></pre> <p>Get the logs of the user's Lab environment.</p> <p>Parameters:</p> Name Type Description Default <code>since</code> <code>int</code> <p>number of seconds to go back in the logs, defaults to 3600</p> <code>3600</code> <code>system</code> <code>bool</code> <p>whether to fetch system logs, defaults to False</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Lab logs</p> Source code in <code>adalib/lab/lab.py</code> <pre><code>def get_lab_logs(since: int = 3600, system: bool = False) -&gt; str:\n    \"\"\"Get the logs of the user's Lab environment.\n\n    :param since: number of seconds to go back in the logs, defaults to 3600\n    :type since: int, optional\n    :param system: whether to fetch system logs, defaults to False\n    :type system: bool, optional\n    :return: Lab logs\n    :rtype: str\n    \"\"\"\n\n    response = adaboard.request_adaboard(\n        path=f\"jupyter/server/logs?since_seconds={since}&amp;system={system}\"\n    ).json()\n\n    return response[\"logs\"]\n</code></pre>"},{"location":"lab/#adalib.lab.get_lab_status","title":"get_lab_status","text":"<pre><code>get_lab_status(metrics=True, options=True)\n</code></pre> <p>Get configuration and status information about the user's Lab environment.</p> <p>Parameters:</p> Name Type Description Default <code>metrics</code> <code>bool</code> <p>whether to fetch Lab metrics, defaults to True</p> <code>True</code> <code>options</code> <code>bool</code> <p>whether to fetch Lab options, defaults to True</p> <code>True</code> <p>Returns:</p> Type Description <code>dict</code> <p>Lab information</p> Source code in <code>adalib/lab/lab.py</code> <pre><code>def get_lab_status(\n    metrics: bool = True, options: bool = True\n) -&gt; dict[\n    str,\n    str\n    | dict[str, float]\n    | list[dict[str, str | int | float | dict[str, str | int | bool]]],\n]:\n    \"\"\"Get configuration and status information about the user's Lab environment.\n\n    :param metrics: whether to fetch Lab metrics, defaults to True\n    :type metrics: bool, optional\n    :param options: whether to fetch Lab options, defaults to True\n    :type options: bool, optional\n    :return: Lab information\n    :rtype: dict\n    \"\"\"\n\n    response = adaboard.request_adaboard(\n        path=f\"jupyter/server?metrics={metrics}&amp;options={options}\"\n    ).json()\n\n    return response\n</code></pre>"},{"location":"lab/#adalib.lab.install_kernel","title":"install_kernel","text":"<pre><code>install_kernel(metadata_id, name, include_notebook=True)\n</code></pre> <p>Install a kernel into the user's Lab environment.</p> <p>Parameters:</p> Name Type Description Default <code>metadata_id</code> <code>int</code> <p>the metadata ID of the kernel to install</p> required <code>name</code> <code>str</code> <p>name to be given to the installed kernel</p> required <code>include_notebook</code> <code>bool</code> <p>whether to include a dummy notebook file with the kernel, defaults to True</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>nothing</p> Source code in <code>adalib/lab/lab.py</code> <pre><code>def install_kernel(\n    metadata_id: int,\n    name: str,\n    include_notebook: bool = True,\n) -&gt; None:\n    \"\"\"Install a kernel into the user's Lab environment.\n\n    :param metadata_id: the metadata ID of the kernel to install\n    :type metadata_id: int\n    :param name: name to be given to the installed kernel\n    :type name: str\n    :param include_notebook: whether to include a dummy notebook file with the kernel, defaults to True\n    :type include_notebook: bool, optional\n    :return: nothing\n    :rtype: None\n    \"\"\"\n\n    # Build request payload with the specified information\n    payload = {\n        \"display_name\": name,\n        \"metadata_id\": metadata_id,\n        \"include_dummy_notebook\": include_notebook,\n    }\n\n    # Install kernel and check response\n    adaboard.request_adaboard(\n        path=\"jupyter/kernelspecs\", method=requests.post, json=payload\n    ).json()\n\n    return None\n</code></pre>"},{"location":"lab/#adalib.lab.stop_lab","title":"stop_lab","text":"<pre><code>stop_lab()\n</code></pre> <p>Stop the user's Lab environment.</p> <p>Returns:</p> Type Description <code>None</code> <p>nothing</p> Source code in <code>adalib/lab/lab.py</code> <pre><code>def stop_lab() -&gt; None:\n    \"\"\"Stop the user's Lab environment.\n\n    :return: nothing\n    :rtype: None\n    \"\"\"\n\n    response = adaboard.request_adaboard(\n        path=\"jupyter/server\", method=requests.delete\n    ).json()\n\n    assert (\n        response[\"message\"] == \"OK\"\n    ), \"The Lab environment could not be stopped.\"\n\n    return None\n</code></pre>"},{"location":"lab/#adalib.lab.uninstall_kernel","title":"uninstall_kernel","text":"<pre><code>uninstall_kernel(name)\n</code></pre> <p>Uninstall a kernel from the user's Lab environment.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the kernel to uninstall</p> required <p>Returns:</p> Type Description <code>None</code> <p>nothing</p> Source code in <code>adalib/lab/lab.py</code> <pre><code>def uninstall_kernel(name: str) -&gt; None:\n    \"\"\"Uninstall a kernel from the user's Lab environment.\n\n    :param name: the name of the kernel to uninstall\n    :type name: str\n    :return: nothing\n    :rtype: None\n    \"\"\"\n\n    response = adaboard.request_adaboard(\n        path=f\"jupyter/kernelspecs/{name}\", method=requests.delete\n    ).json()\n\n    assert response[\"message\"] == \"OK\", \"The kernel could not be uninstalled.\"\n\n    return None\n</code></pre>"},{"location":"lab/#adalib.lab.who_am_i","title":"who_am_i","text":"<pre><code>who_am_i()\n</code></pre> <p>Get information about the current user.</p> <p>Returns:</p> Type Description <code>dict</code> <p>information about the current user</p> Source code in <code>adalib/lab/lab.py</code> <pre><code>def who_am_i() -&gt; dict[str, str]:\n    \"\"\"Get information about the current user.\n\n    :return: information about the current user\n    :rtype: dict\n    \"\"\"\n\n    response = adaboard.request_adaboard(path=\"users/self\").json()\n\n    return response\n</code></pre>"},{"location":"notebooks/","title":"<code>adalib.notebooks</code>","text":"<p>The Notebooks sub-package exposes the core integrations of the notebook runs and schedules in the AdaLab Gallery.</p>"},{"location":"notebooks/#adalib.notebooks-functions","title":"Functions","text":""},{"location":"notebooks/#adalib.notebooks.create_notebook_schedule","title":"create_notebook_schedule","text":"<pre><code>create_notebook_schedule(card_id, config)\n</code></pre> <p>Update a notebook schedule with the provided configuration.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>int</code> <p>The card's ID for the notebook schedule</p> required <code>config</code> <code>dict[str, str | int | bool | dict | None]</code> <p>A dictionary containing the schedule configuration.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the update was successful, False otherwise.</p> Source code in <code>adalib/notebooks/schedules.py</code> <pre><code>def create_notebook_schedule(\n    card_id: int, config: dict[str, str | int | bool | dict | None]\n) -&gt; bool:\n    \"\"\"\n    Update a notebook schedule with the provided configuration.\n\n    :param card_id: The card's ID for the notebook schedule\n    :type card_id: int\n    :param config: A dictionary containing the schedule configuration.\n    :type config: dict\n\n    The `config` dictionary must contain the following keys:\n    - \"user_id\" (str): The user's ID.\n    - \"schedule\" (str): The schedule time string in cron format.\n    - \"pool\" (str): The execution pool.\n    - \"active\" (bool): Whether the schedule is active.\n    - \"concurrent\" (bool): Whether the schedule can run concurrently.\n    - \"cleanup\" (bool): Whether to clean up resources after the schedule.\n    - \"inputs\" (dict): A dictionary of input parameters for the schedule.\n\n    The following keys are optional:\n    - \"timeout\" (int): The maximum time (in seconds) before killing the run.\n    - \"pre_run_script\" (str): A pre-run script to execute.\n    - \"post_run_script\" (str): A post-run script to execute.\n\n    :return: True if the update was successful, False otherwise.\n    :rtype: bool\n    \"\"\"\n    mandatory_keys = {\n        \"user_id\",\n        \"schedule\",\n        \"pool\",\n        \"active\",\n        \"concurrent\",\n        \"cleanup\",\n        \"inputs\",\n    }\n    allowed_keys = mandatory_keys.union(\n        {\"timeout\", \"pre_run_script\", \"post_run_script\"}\n    )\n\n    if not set(config.keys()).issubset(allowed_keys):\n        raise AssertionError(\"Invalid keys in the configuration.\")\n\n    if not mandatory_keys.issubset(config.keys()):\n        raise AssertionError(\n            \"Mandatory keys are missing in the configuration.\"\n        )\n\n    path = f\"card_runner/schedule/{card_id}/\"\n    try:\n        response = adaboard.request_adaboard(\n            path=path,\n            method=requests.post,\n            json=config,\n        )\n        return response.status_code == 204\n    except requests.exceptions.HTTPError as e:\n        logging.error(\"Failed to create schedule. Error: %s\", e)\n        return False\n</code></pre>"},{"location":"notebooks/#adalib.notebooks.delete_notebook_run","title":"delete_notebook_run","text":"<pre><code>delete_notebook_run(run_id)\n</code></pre> <p>Delete a notebook run identified by its run ID.</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>int</code> <p>The ID of the notebook run to be deleted.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the deletion was successful, False otherwise.</p> Source code in <code>adalib/notebooks/single_runs.py</code> <pre><code>def delete_notebook_run(run_id: int) -&gt; bool:\n    \"\"\"\n    Delete a notebook run identified by its run ID.\n\n    :param run_id: The ID of the notebook run to be deleted.\n    :type run_id: int\n    :return: True if the deletion was successful, False otherwise.\n    :rtype: bool\n    \"\"\"\n    path = f\"card_runner/runs/{run_id}/\"\n    try:\n        response = adaboard.request_adaboard(path=path, method=requests.delete)\n        return response.status_code == 204\n    except requests.exceptions.HTTPError as e:\n        logging.error(\"Failed to delete Run ID %s. Error: %s\", str(run_id), e)\n        return False\n</code></pre>"},{"location":"notebooks/#adalib.notebooks.delete_notebook_schedule","title":"delete_notebook_schedule","text":"<pre><code>delete_notebook_schedule(card_id)\n</code></pre> <p>Delete a specific notebook schedule for a user.</p> <p>This function removes a scheduled run of a Jupyter notebook for a given user and card ID. It requires user authentication via JupyterHub token.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>int</code> <p>The unique identifier of the card associated with the notebook schedule.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the deletion was successful, False otherwise.</p> Source code in <code>adalib/notebooks/schedules.py</code> <pre><code>def delete_notebook_schedule(\n    card_id: int,\n) -&gt; bool:\n    \"\"\"\n    Delete a specific notebook schedule for a user.\n\n    This function removes a scheduled run of a Jupyter notebook for a given user and card ID.\n    It requires user authentication via JupyterHub token.\n\n    :param card_id: The unique identifier of the card associated with the notebook schedule.\n    :type card_id: int\n    :return: True if the deletion was successful, False otherwise.\n    :rtype: bool\n    \"\"\"\n    user_id = adaboard.get_user()[\"user_id\"]\n    path = f\"card_runner/schedule/{card_id}/\"\n    params = {\"user_id\": user_id}\n    try:\n        response = adaboard.request_adaboard(\n            path=path,\n            method=requests.delete,\n            params=params,\n        )\n\n        return response.status_code == 204\n    except requests.exceptions.HTTPError as e:\n        logging.error(\"Failed to delete schedule. Error: %s\", e)\n        return False\n</code></pre>"},{"location":"notebooks/#adalib.notebooks.get_all_pages","title":"get_all_pages","text":"<pre><code>get_all_pages(api_url, params=None)\n</code></pre> <p>Fetch all pages of data from a paginated API and return the combined results.</p> <p>Parameters:</p> Name Type Description Default <code>api_url</code> <code>str</code> <p>The base API URL to request data from.</p> required <code>params</code> <code>dict</code> <p>Additional query parameters for the API request.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>A list of items from all pages.</p> Source code in <code>adalib/notebooks/single_runs.py</code> <pre><code>def get_all_pages(api_url: str, params: dict = None) -&gt; list[dict]:\n    \"\"\"\n    Fetch all pages of data from a paginated API and return the combined results.\n\n    :param api_url: The base API URL to request data from.\n    :type api_url: str\n    :param params: Additional query parameters for the API request.\n    :type params: dict\n    :return: A list of items from all pages.\n    :rtype: list[dict]\n    \"\"\"\n    all_responses = []\n    current_page = 1\n\n    while True:\n        if params is None:\n            params = {}\n        params[\"page\"] = current_page\n\n        response = adaboard.request_adaboard(\n            path=api_url, method=requests.get, params=params\n        ).json()\n\n        all_responses.extend(response.get(\"items\"))\n        total_pages = response.get(\"pages\")\n\n        if current_page &gt;= total_pages:\n            break\n\n        current_page += 1\n\n    return all_responses\n</code></pre>"},{"location":"notebooks/#adalib.notebooks.get_all_schedules","title":"get_all_schedules","text":"<pre><code>get_all_schedules()\n</code></pre> <p>Retrieve a list of schedules for all users.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>A list of notebook run schedules in dictionary form.</p> Source code in <code>adalib/notebooks/schedules.py</code> <pre><code>def get_all_schedules() -&gt; list[dict]:\n    \"\"\"\n    Retrieve a list of schedules for all users.\n\n    :return: A list of notebook run schedules in dictionary form.\n    :rtype: list[dict]\n    \"\"\"\n    api_url = \"card_runner/schedule/all/\"\n    return adaboard.request_adaboard(path=api_url, method=requests.get).json()\n</code></pre>"},{"location":"notebooks/#adalib.notebooks.get_notebook_run_info","title":"get_notebook_run_info","text":"<pre><code>get_notebook_run_info(run_id)\n</code></pre> <p>Get information about a specific notebook run identified by its run ID.</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>int</code> <p>The ID of the notebook run to retrieve information for.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Information about the notebook run.</p> Source code in <code>adalib/notebooks/single_runs.py</code> <pre><code>def get_notebook_run_info(run_id: int) -&gt; dict:\n    \"\"\"\n    Get information about a specific notebook run identified by its run ID.\n\n    :param run_id: The ID of the notebook run to retrieve information for.\n    :type run_id: int\n    :return: Information about the notebook run.\n    :rtype: dict\n    \"\"\"\n    path = f\"card_runner/runs/{run_id}/\"\n    try:\n        response = adaboard.request_adaboard(path=path, method=requests.get)\n        return response.json()\n    except requests.exceptions.HTTPError as e:\n        logging.error(\n            \"Failed to retrieve information for Run ID %s. Error: %s\",\n            str(run_id),\n            e,\n        )\n        return {}\n</code></pre>"},{"location":"notebooks/#adalib.notebooks.get_notebook_run_logs","title":"get_notebook_run_logs","text":"<pre><code>get_notebook_run_logs(run_id)\n</code></pre> <p>Retrieve logs for a notebook run identified by its run ID.</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>int</code> <p>The ID of the notebook run for which logs should be retrieved.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the logs for the specified run.</p> Source code in <code>adalib/notebooks/single_runs.py</code> <pre><code>def get_notebook_run_logs(run_id: int) -&gt; dict:\n    \"\"\"\n    Retrieve logs for a notebook run identified by its run ID.\n\n    :param run_id: The ID of the notebook run for which logs should be retrieved.\n    :type run_id: int\n    :return: A dictionary containing the logs for the specified run.\n    :rtype: dict\n    \"\"\"\n    path = f\"card_runner/runs/{run_id}/logs/\"\n\n    all_run_ids = [\n        run_id for entry in get_runs_overview() for run_id in entry[\"run_ids\"]\n    ]\n\n    assert (\n        run_id in all_run_ids\n    ), f\"Run ID {run_id} is not in the list of available run IDs\"\n\n    try:\n        response = adaboard.request_adaboard(path=path, method=requests.get)\n        return response.json()\n    except requests.exceptions.HTTPError as e:\n        logging.error(\n            \"Failed to retrieve logs for Run ID %s. Error: %s\",\n            str(run_id),\n            str(e),\n        )\n        return {}\n</code></pre>"},{"location":"notebooks/#adalib.notebooks.get_run_instances","title":"get_run_instances","text":"<pre><code>get_run_instances(card_id, user_id)\n</code></pre> <p>Get all notebook runs from a specific card and user. Non-admin users can only access their own runs.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>int</code> <p>The ID of the card from which to retrieve notebook runs.</p> required <code>user_id</code> <code>str</code> <p>The user ID for authentication.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>A list of notebook run instances for the specified card and user.</p> Source code in <code>adalib/notebooks/single_runs.py</code> <pre><code>def get_run_instances(card_id: int, user_id: str) -&gt; list[dict]:\n    \"\"\"\n    Get all notebook runs from a specific card and user.\n    Non-admin users can only access their own runs.\n\n    :param card_id: The ID of the card from which to retrieve notebook runs.\n    :type card_id: int\n    :param user_id: The user ID for authentication.\n    :type user_id: str\n    :return: A list of notebook run instances for the specified card and user.\n    :rtype: list[dict]\n    \"\"\"\n    user_info = adaboard.get_user()\n    user_id_auth = user_info[\"user_id\"]\n    if user_id != user_id_auth:\n        assert (\n            \"PlatformAdmin\" in user_info[\"roles\"][\"adaboard\"]\n        ), \"Only admin user can access the notebook runs of another user\"\n\n    api_url = \"card_runner/runs/instances/\"\n    params = {\"user_id\": user_id, \"card_id\": card_id}\n    try:\n        return get_all_pages(api_url=api_url, params=params)\n    except requests.exceptions.HTTPError as e:\n        logging.error(\"Failed to get run instances. Error: %s\", e)\n        return []\n</code></pre>"},{"location":"notebooks/#adalib.notebooks.get_runs_overview","title":"get_runs_overview","text":"<pre><code>get_runs_overview()\n</code></pre> <p>Retrieve all notebooks runs grouped by card ID. Non-admin users can only access their own runs.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>A list of notebook run overview information in dictionary form.</p> Source code in <code>adalib/notebooks/single_runs.py</code> <pre><code>def get_runs_overview() -&gt; list[dict]:\n    \"\"\"\n    Retrieve all notebooks runs grouped by card ID.\n    Non-admin users can only access their own runs.\n\n    :return: A list of notebook run overview information in dictionary form.\n    :rtype: list[dict]\n    \"\"\"\n    api_url = \"card_runner/runs/overview/\"\n    try:\n        return get_all_pages(api_url=api_url)\n    except requests.exceptions.HTTPError as e:\n        logging.error(\"Failed get runs overview. Error: %s\", e)\n        return []\n</code></pre>"},{"location":"notebooks/#adalib.notebooks.get_schedules_by_card_id","title":"get_schedules_by_card_id","text":"<pre><code>get_schedules_by_card_id(card_id)\n</code></pre> <p>Retrieve all user-specific schedules for a specified card.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>int</code> <p>The card's ID.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>A list of notebook run schedules in dictionary form.</p> Source code in <code>adalib/notebooks/schedules.py</code> <pre><code>def get_schedules_by_card_id(card_id: int) -&gt; list[dict]:\n    \"\"\"\n    Retrieve all user-specific schedules for a specified card.\n\n    :param card_id: The card's ID.\n    :type card_id: int\n    :return: A list of notebook run schedules in dictionary form.\n    :rtype: list[dict]\n    \"\"\"\n    api_url = f\"card_runner/schedule/{card_id}/\"\n    return adaboard.request_adaboard(path=api_url, method=requests.get).json()\n</code></pre>"},{"location":"notebooks/#adalib.notebooks.get_schedules_by_card_id_all_users","title":"get_schedules_by_card_id_all_users","text":"<pre><code>get_schedules_by_card_id_all_users(card_id)\n</code></pre> <p>Retrieve all users schedules for a specified card.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>int</code> <p>The card's ID.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>A list of notebook run schedules in dictionary form.</p> Source code in <code>adalib/notebooks/schedules.py</code> <pre><code>def get_schedules_by_card_id_all_users(card_id: int) -&gt; list[dict]:\n    \"\"\"\n    Retrieve all users schedules for a specified card.\n\n    :param card_id: The card's ID.\n    :type card_id: int\n    :return: A list of notebook run schedules in dictionary form.\n    :rtype: list[dict]\n    \"\"\"\n    api_url = f\"card_runner/schedule/{card_id}/all/\"\n    return adaboard.request_adaboard(path=api_url, method=requests.get).json()\n</code></pre>"},{"location":"notebooks/#adalib.notebooks.get_user_schedules","title":"get_user_schedules","text":"<pre><code>get_user_schedules()\n</code></pre> <p>Retrieve a list of schedules for the specified user.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>A list of notebook run schedules in dictionary form.</p> Source code in <code>adalib/notebooks/schedules.py</code> <pre><code>def get_user_schedules() -&gt; list[dict]:\n    \"\"\"\n    Retrieve a list of schedules for the specified user.\n\n    :return: A list of notebook run schedules in dictionary form.\n    :rtype: list[dict]\n    \"\"\"\n    api_url = \"card_runner/schedule/\"\n    return adaboard.request_adaboard(path=api_url, method=requests.get).json()\n</code></pre>"},{"location":"notebooks/#adalib.notebooks.start_notebook","title":"start_notebook","text":"<pre><code>start_notebook(card_id, timeout=3600, pool='card-runner-low', cleanup=True, inputs=None, pre_run_script='', post_run_script='')\n</code></pre> <p>Starts a notebook run on an AdaBoard card with the provided parameters. If successful, returns the Run ID for the started notebook run. If the request fails, returns None.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>int</code> <p>The ID of the AdaBoard card to run the notebook on.</p> required <code>timeout</code> <code>float</code> <p>The maximum time (in seconds) to wait for the notebook to complete.</p> <code>3600</code> <code>pool</code> <code>str</code> <p>The execution pool to use for the notebook run.</p> <code>'card-runner-low'</code> <code>cleanup</code> <code>bool</code> <p>Whether to clean up resources after the notebook run.</p> <code>True</code> <code>inputs</code> <code>dict | None</code> <p>A dictionary of input parameters for the notebook.</p> <code>None</code> <code>pre_run_script</code> <code>str</code> <p>A pre-run script to be executed before running the notebook.</p> <code>''</code> <code>post_run_script</code> <code>str</code> <p>A post-run script to be executed after running the notebook.</p> <code>''</code> <p>Returns:</p> Type Description <code>int | None</code> <p>The Run ID if successful, None otherwise.</p> Source code in <code>adalib/notebooks/single_runs.py</code> <pre><code>def start_notebook(\n    card_id: int,\n    timeout: float = 3600,\n    pool: str = \"card-runner-low\",\n    cleanup: bool = True,\n    inputs: dict | None = None,\n    pre_run_script: str = \"\",\n    post_run_script: str = \"\",\n) -&gt; int:\n    \"\"\"\n    Starts a notebook run on an AdaBoard card with the provided parameters.\n    If successful, returns the Run ID for the started notebook run. If the request\n    fails, returns None.\n\n    :param card_id: The ID of the AdaBoard card to run the notebook on.\n    :type card_id: int\n    :param timeout: The maximum time (in seconds) to wait for the notebook to complete.\n    :type timeout: float, optional\n    :param pool: The execution pool to use for the notebook run.\n    :type pool: str, optional\n    :param cleanup: Whether to clean up resources after the notebook run.\n    :type cleanup: bool, optional\n    :param inputs: A dictionary of input parameters for the notebook.\n    :type inputs: dict | None, optional\n    :param pre_run_script: A pre-run script to be executed before running the notebook.\n    :type pre_run_script: str, optional\n    :param post_run_script: A post-run script to be executed after running the notebook.\n    :type post_run_script: str, optional\n    :return: The Run ID if successful, None otherwise.\n    :rtype: int | None\n    \"\"\"\n    valid_pools = [\"card-runner-low\", \"card-runner-high\", \"card-runner-medium\"]\n    if pool not in valid_pools:\n        raise ValueError(\n            f\"Invalid pool choice '{pool}'. Valid options are {valid_pools}.\"\n        )\n    payload = {\n        \"card_id\": card_id,\n        \"user_id\": adaboard.get_user()[\"user_id\"],\n        \"timeout\": timeout,\n        \"pool\": pool,\n        \"cleanup\": cleanup,\n        \"inputs\": inputs if inputs else {},\n        \"pre_run_script\": pre_run_script,\n        \"post_run_script\": post_run_script,\n    }\n    path = \"card_runner/runs/start/\"\n    try:\n        response = adaboard.request_adaboard(\n            path=path, method=requests.post, json=payload\n        )\n        run_id = response.json()[\"id\"]\n        logging.info(\n            \"Card %s running with Run ID %s\", str(card_id), str(run_id)\n        )\n        return run_id\n    except requests.exceptions.HTTPError as e:\n        logging.error(\"Failed to start notebook. Error: %s\", e)\n        return 0\n</code></pre>"},{"location":"notebooks/#adalib.notebooks.stop_notebook","title":"stop_notebook","text":"<pre><code>stop_notebook(run_id)\n</code></pre> <p>Stops a running notebook using the Run ID by sending a request to the AdaBoard server to terminate the specified notebook run. If successful, it prints a message confirming the termination of the notebook run. If the request fails, it prints the status code of the failed request.</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>int</code> <p>The ID of the notebook run to be stopped.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>adalib/notebooks/single_runs.py</code> <pre><code>def stop_notebook(run_id: int) -&gt; None:\n    \"\"\"\n    Stops a running notebook using the Run ID by sending a request to the AdaBoard\n    server to terminate the specified notebook run. If successful, it prints a message\n    confirming the termination of the notebook run. If the request fails, it prints\n    the status code of the failed request.\n\n    :param run_id: The ID of the notebook run to be stopped.\n    :type run_id: int\n    :return: None\n    :rtype: None\n    \"\"\"\n    path = f\"card_runner/runs/{run_id}/stop/\"\n    params = {\"run_id\": run_id}\n    try:\n        response = adaboard.request_adaboard(\n            path=path, method=requests.post, params=params\n        )\n        logging.info(\"Run ID %s succesfully stopped\", str(run_id))\n        assert response.status_code == 204\n        return True\n    except requests.exceptions.HTTPError as e:\n        logging.error(\n            \"Failed to stop notebook with run ID %s. Error: %s\", str(run_id), e\n        )\n        return False\n</code></pre>"},{"location":"notebooks/#adalib.notebooks.update_notebook_run","title":"update_notebook_run","text":"<pre><code>update_notebook_run(run_id, status=None, log_info=None)\n</code></pre> <p>Update a notebook run identified by its run ID with the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>int</code> <p>The ID of the notebook run to be updated.</p> required <code>status</code> <code>int</code> <p>The updated status for the notebook run (optional). Valid values are 1 (PENDING), 2 (RUNNING), 3 (OK), and 4 (ERROR).</p> <code>None</code> <code>log_info</code> <code>dict</code> <p>Information for creating the log (optional).</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the update was successful, False otherwise.</p> Source code in <code>adalib/notebooks/single_runs.py</code> <pre><code>def update_notebook_run(\n    run_id: int, status: int = None, log_info: dict = None\n) -&gt; bool:\n    \"\"\"\n    Update a notebook run identified by its run ID with the provided parameters.\n\n    :param run_id: The ID of the notebook run to be updated.\n    :type run_id: int\n    :param status: The updated status for the notebook run (optional).\n                   Valid values are 1 (PENDING), 2 (RUNNING), 3 (OK), and 4 (ERROR).\n    :type status: int, optional\n    :param log_info: Information for creating the log (optional).\n    :type log_info: dict, optional\n\n    If provided, the log_info dictionary should include the following keys:\n\n    - \"timestamp\" (datetime): The timestamp for the log entry (mandatory).\n    - \"type\" (str): The type of log entry, either \"system\" or \"notebook\" (mandatory).\n    - \"output\" (str): The log output (mandatory).\n    - \"input\" (str, optional): The input data (if applicable).\n    - \"language\" (str, optional): The programming language used (if applicable).\n    - \"cell_number\" (int, optional): The cell number (if applicable).\n    - \"cell_status\" (str, optional): The cell status with possible values:\n                                    [\"ok\", \"error\", \"running\", \"skipped\"].\n    - \"cell_type\" (str, optional): The cell type (if applicable).\n\n    :return: True if the update was successful, False otherwise.\n    :rtype: bool\n    \"\"\"\n    valid_status_values = {1, 2, 3, 4}\n\n    if status is not None:\n        assert (\n            status in valid_status_values\n        ), \"Invalid status value. Valid values are 1, 2, 3, 4.\"\n\n    path = f\"card_runner/runs/{run_id}/\"\n    payload = {}\n\n    if status is not None:\n        payload[\"status\"] = status\n\n    if log_info is not None:\n        payload[\"log\"] = [log_info]\n\n    params = {\"run_id\": run_id}\n\n    response = adaboard.request_adaboard(\n        path=path, method=requests.put, json=payload, params=params\n    )\n\n    if response.status_code == 204:\n        return True\n    else:\n        logging.error(\n            \"Failed to update Run ID %s. Status code: %s\",\n            str(run_id),\n            response.status_code,\n        )\n        return False\n</code></pre>"},{"location":"notebooks/#adalib.notebooks.update_notebook_schedule","title":"update_notebook_schedule","text":"<pre><code>update_notebook_schedule(card_id, config)\n</code></pre> <p>Update a notebook schedule with the provided configuration.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>int</code> <p>The card's ID for the notebook schedule</p> required <code>config</code> <code>dict[str, str | int | bool | dict | None]</code> <p>A dictionary containing the schedule configuration.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the update was successful, False otherwise.</p> Source code in <code>adalib/notebooks/schedules.py</code> <pre><code>def update_notebook_schedule(\n    card_id: int, config: dict[str, str | int | bool | dict | None]\n) -&gt; bool:\n    \"\"\"\n    Update a notebook schedule with the provided configuration.\n\n    :param card_id: The card's ID for the notebook schedule\n    :type card_id: int\n    :param config: A dictionary containing the schedule configuration.\n    :type config: dict\n\n    The `config` dictionary must contain the following keys:\n    - \"user_id\" (str): The user's ID.\n    - \"schedule\" (str): The schedule time string in cron format.\n    - \"pool\" (str): The execution pool.\n    - \"active\" (bool): Whether the schedule is active.\n    - \"concurrent\" (bool): Whether the schedule can run concurrently.\n    - \"cleanup\" (bool): Whether to clean up resources after the schedule.\n    - \"inputs\" (dict): A dictionary of input parameters for the schedule.\n\n    The following keys are optional:\n    - \"timeout\" (int): The maximum time (in seconds) before killing the run.\n    - \"pre_run_script\" (str): A pre-run script to execute.\n    - \"post_run_script\" (str): A post-run script to execute.\n\n    :return: True if the update was successful, False otherwise.\n    :rtype: bool\n    \"\"\"\n    mandatory_keys = {\n        \"user_id\",\n        \"schedule\",\n        \"pool\",\n        \"active\",\n        \"concurrent\",\n        \"cleanup\",\n        \"inputs\",\n    }\n    allowed_keys = mandatory_keys.union(\n        {\"timeout\", \"pre_run_script\", \"post_run_script\"}\n    )\n\n    if not set(config.keys()).issubset(allowed_keys):\n        raise AssertionError(\"Invalid keys in the configuration.\")\n\n    if not mandatory_keys.issubset(config.keys()):\n        raise AssertionError(\n            \"Mandatory keys are missing in the configuration.\"\n        )\n\n    path = f\"card_runner/schedule/{card_id}/\"\n    try:\n        response = adaboard.request_adaboard(\n            path=path,\n            method=requests.put,\n            json=config,\n        )\n        return response.status_code == 204\n    except requests.exceptions.HTTPError as e:\n        logging.error(\"Failed to update schedule. Error: %s\", e)\n        return False\n</code></pre>"},{"location":"superset/","title":"<code>adalib.superset</code>","text":"<p>The Superset sub-package exposes the core integrations with the Superset data platform connected to AdaLab.</p>"},{"location":"superset/#adalib.superset-classes","title":"Classes","text":""},{"location":"superset/#adalib.superset-functions","title":"Functions","text":""},{"location":"superset/#adalib.superset.get_client","title":"get_client","text":"<pre><code>get_client(token=None)\n</code></pre> <p>Create a client for communicating with the Superset API</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <p>An OAuth token valid for authenticating with the Superset API. Optional if we're running in JupyterHub</p> <code>None</code> <p>Returns:</p> Type Description <code>OAuthSupersetClient</code> <p>authenticated Superset client</p> Source code in <code>adalib/superset/__init__.py</code> <pre><code>def get_client(token=None):\n    \"\"\"Create a client for communicating with the Superset API\n\n    :param token: An OAuth token valid for authenticating with the Superset API.\n                  Optional if we're running in JupyterHub\n    :return: authenticated Superset client\n    :rtype: OAuthSupersetClient\n    \"\"\"\n    return OAuthSupersetClient(oauth_token=token)\n</code></pre>"}]}